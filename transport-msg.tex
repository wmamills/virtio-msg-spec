\section{Virtio Over Messages}\label{sec:Virtio Transport Options / Virtio Over Messages}

\newcommand{\conceptref}[1]{\hyperref[sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts / #1]{#1}}
\newcommand{\msgref}[1]{\hyperref[sec:Virtio Transport Options / Virtio Over Messages / Transport Messages / VIRTIO_MSG_#1]{VIRTIO_MSG_#1}}
\newcommand{\busref}[1]{\hyperref[sec:Virtio Transport Options / Virtio Over Messages / Bus Messages / BUS_MSG_#1]{BUS_MSG_#1}}
\newcommand{\msgdef}[1]{\subsubsection{VIRTIO_MSG_#1}\label{sec:Virtio Transport Options / Virtio Over Messages / Transport Messages / VIRTIO_MSG_#1}}
\newcommand{\busdef}[1]{\subsubsection{BUS_MSG_#1}\label{sec:Virtio Transport Options / Virtio Over Messages / Bus Messages / BUS_MSG_#1}}

This section defines \textbf{virtio-msg}, a transport mechanism that encapsulates
virtio operations as discrete message exchanges rather than relying on PCI or
memory-mapped I/O regions. It separates bus-level functionality (e.g., device
enumeration, hotplug events) from device-specific operations (e.g., feature
negotiation, virtqueue setup), ensuring that a single, generic transport layer
can be reused across multiple bus implementations.

virtio-msg addresses several key objectives:

\begin{itemize}
  \item \textbf{Support multiple bus implementations:}
  Systems can rely on various communication methods such as hypercalls, local
  IPC, network channels, or device trees for enumerating devices. virtio-msg
  defines a common transport interface suitable for any of these mechanisms.

  \item \textbf{Reduce per-bus complexity:}
  Buses can implement a fully message-based workflow (including optional
  enumeration via \busref{GET_DEVICES} and hotplug via \busref{EVENT_DEVICE})
  or they can discover and manage devices through
  alternative means such as platform firmware data. In either case, they
  forward transport messages to and from each device.

  \item \textbf{Preserve virtio semantics:}
  The transport leverages standard virtio concepts (features, configuration
  space, virtqueues), so existing virtio drivers and device implementations can
  integrate smoothly once a device is discovered and registered.
\end{itemize}

\subsection{Basic Concepts}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts}

The virtio-msg transport relies on a set of foundational concepts to ensure
reusability across different bus implementations and flexibility in device
capabilities. This section defines those concepts and clarifies how they apply,
regardless of whether the bus leverages message-based enumeration or platform
data for device discovery.

\subsubsection{High-Level Architecture}

virtio-msg operates around two layers:

\begin{enumerate}
  \item \textbf{Bus Layer}: A \emph{bus instance} exposes zero or more virtio
        devices. It discovers available devices through mechanisms such as:
    \begin{itemize}
      \item Optional message-based queries (\busref{GET_DEVICES}),
      \item External data sources (e.g., device tree, ACPI tables, hypervisor
        firmware calls),
      \item Dynamic hotplug notifications (optionally via \busref{EVENT_DEVICE}).
    \end{itemize}
    Once a device is identified, regardless of discovery method, the bus
    uses \msgref{GET_DEVICE_INFO} to read its device ID and vendor ID, then
    \emph{registers} that device with the host OS so the usual virtio driver
    probe can occur.

  \item \textbf{Transport Layer}: After the bus knows about a device, the
        virtio-msg transport handles all device-specific operations:
    \begin{itemize}
      \item Retrieving and setting features (\msgref{GET_DEVICE_FEATURES},
        \msgref{SET_DRIVER_FEATURES}),
      \item Accessing the device configuration space (\msgref{GET_CONFIG},
        \msgref{SET_CONFIG}),
      \item Setting up virtqueues (\msgref{SET_VQUEUE}, \msgref{RESET_VQUEUE}),
      \item Managing status and runtime notifications (\msgref{SET_DEVICE_STATUS},
        \msgref{EVENT_USED}, etc.).
    \end{itemize}
    These transport messages remain the same across different bus instances,
    allowing a single virtio-msg driver component to function in multiple
    environments.
\end{enumerate}

\subsubsection{Relationship Between Bus and Transport}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts / Relationship between bus and transport}

This subsubsection explains the division of responsibilities: the bus layer is
the mandatory carrier that moves messages between driver and device endpoints
(e.g., over IPC, shared memory with signalling or hardware messaging), while
the virtio-msg transport defines the semantics of those messages.

virtio-msg groups messages into two categories:

\begin{description}
  \item[\textbf{Bus Messages}:]
    Intended for global bus operations such as enumerating device numbers
    (\busref{GET_DEVICES}), managing device hotplug events (\busref{EVENT_DEVICE})
    or assessing bus-wide health (\busref{PING}).
    These messages are \emph{optional} in environments where
    device discovery or state changes occur through other means (e.g., device
    tree). However, if a bus chooses to handle those tasks via messages,
    it implements the appropriate bus message definitions described in this
    section.

  \item[\textbf{Transport Messages}:]
    Used for device-specific operations, such as:
    \begin{itemize}
      \item Retrieving or setting features (\msgref{GET_DEVICE_FEATURES},
        \msgref{SET_DRIVER_FEATURES}),
      \item Accessing device configuration (\msgref{GET_CONFIG},
        \msgref{SET_CONFIG}),
      \item Managing virtqueues (\msgref{SET_VQUEUE}, \msgref{RESET_VQUEUE}),
      \item Handling device status and notifications (\msgref{SET_DEVICE_STATUS},
        \msgref{EVENT_USED}, etc.).
    \end{itemize}
\end{description}

This separation lets a bus remain minimal if it obtains device information from
firmware tables, while still supporting fully message-based enumeration and
hotplug when desired.

\busnormative{\paragraph}{Bus Message Implementation}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Relationship between bus and transport / Bus Messages}
\begin{itemize}
  \item A bus implementation that provides enumeration, hotplug, or bus
        health handling via bus messages SHOULD implement the corresponding Bus
        Message definitions described in this section.
\end{itemize}

\busnormative{\paragraph}{Transport Message Forwarding}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Relationship between bus and transport / Transport Message Forwarding}
\begin{itemize}
  \item A bus implementation MUST relay each transport message to the device
        number identified in the message header, regardless of how it
        discovered or enumerated that device.
  \item A bus implementation SHOULD treat transport messages as opaque apart
        from enforcing generic transport limits, such as the advertised maximum
        message size, and SHOULD NOT modify the transport payload.
\end{itemize}

\subsubsection{System Topology}

A virtio-msg system contains the following elements:

\begin{itemize}
  \item \textbf{Bus Instances and Devices}: Each bus instance advertises its
        capabilities (e.g., transport revision, maximum message size) and
        discovers devices via message-based queries or external data sources.
        Every discovered device has a unique \emph{device number}.
  \item \textbf{Driver}: Communicates with the bus to learn about
        available devices. Once a device is recognized, the driver uses the
        common transport messages to perform feature negotiation, configuration,
        and virtqueue setup.
  \item \textbf{Device}: Implement virtio device functionality and
        respond to the transport messages. The bus forwards these messages to
        the correct device instance based on device number.
\end{itemize}

\subsubsection{Transport Revisions and Maximum Message Size}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts / Revisions}

Each \textbf{virtio-msg bus instance} advertises the following to the transport
layer:
\begin{itemize}
  \item \textbf{Transport revision}: the protocol version supported by the bus
        instance (independent of the overall Virtio specification version).
  \item \textbf{Maximum message size}: the largest payload (in bytes) that can
        be carried per request or response, including the common header.
  \item \textbf{Transport feature bits}: revision-specific optional features
        implemented by the bus instance.
\end{itemize}

The mechanism for obtaining these parameters is implementation-defined and can
vary between bus instances. Common approaches include:
\begin{itemize}
  \item Reading firmware or device-tree data that describes each bus instance,
  \item Performing a message exchange during bus setup to retrieve the values,
  \item Relying on per-bus configuration structures or driver-specific defaults.
\end{itemize}

\busnormative{\paragraph}{Advertising Transport Parameters}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Revisions / Advertising Transport Parameters}
\begin{itemize}
  \item Each bus instance MUST make its transport revision, maximum message
        size, and transport feature bits available to the virtio-msg transport
        before any transport messages are exchanged for that device.
  \item A bus instance MUST apply the same limits to both driver-originated and
        device-originated transport messages; if the values change, the bus
        MUST inform the transport layer before accepting additional messages.
\end{itemize}

\drivernormative{\paragraph}{Respecting Bus Limits (Driver)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Revisions / Driver Limits}
\begin{itemize}
  \item A driver MUST NOT send a transport message whose total size exceeds the
        maximum message size advertised for the target bus instance.
  \item A driver MUST NOT rely on transport features or messages that require a
        higher transport revision than the bus instance reports.
\end{itemize}

\devicenormative{\paragraph}{Respecting Bus Limits (Device)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Revisions / Device Limits}
\begin{itemize}
  \item A device MUST ensure its responses and device-originated messages do
        not exceed the maximum message size advertised by the bus instance that
        relays them.
  \item A device MUST NOT require transport features or messages beyond the
        transport revision reported by the bus instance, and MUST respond with
        an error or ignore requests for unsupported features.
\end{itemize}

\paragraph{virtio-msg revisions}

The following table lists the currently defined virtio-msg revisions:

\begin{tabular}{ |l|l|l|l| }
\hline
\field{revision} & \field{maximum size} & \field{features}      & remarks \\
\hline \hline
1        & 44-65536    & <empty>   & Virtio Message Revision 1 \\
\hline
\end{tabular}

Note that a change in the virtio standard does not necessarily
correspond to a change in the virtio-msg revision.

The maximum message size is specified from the transport-layer point of view
and includes the 8-byte common header plus payload. Any extra encapsulation
imposed by the underlying bus (for example, a framing header) does not count
against this limit. Today the largest practical transport payload is 256 bytes:
messages such as GET_CONFIG and SET_CONFIG can carry up to 256 bytes of device
configuration in one transfer, and larger configuration regions can be accessed
through multiple exchanges without requiring a larger per-message limit.

\busnormative{\paragraph}{Message Size Bounds}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Revisions / Message Size}
\begin{itemize}
  \item A bus implementation MUST advertise a maximum message size of at least
        44 bytes.
  \item A bus implementation SHOULD NOT advertise a maximum message size that
        exceeds 264 bytes (256-byte payload plus the common header).
\end{itemize}

\paragraph{Versioning and Forward Compatibility}

A higher transport revision or additional transport feature bits extend the
protocol with new messages or capabilities. Implementations are expected to
remain interoperable across revisions: devices and drivers designed for a newer
revision still implement the mandatory messages and semantics defined in prior
revisions.

\drivernormative{\paragraph}{Revision Compatibility}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Versioning and Forward Compatibility / Driver}
\begin{itemize}
  \item A driver that negotiates transport revision $N$ MUST implement all
        mandatory driver behavior defined for revisions $1$ through $N$.
  \item If a driver receives a device-originated message or feature indication
        that requires an unsupported revision or transport feature, it MUST
        ignore the message (or treat the request as failed) and MUST NOT act on
        partially understood data.
\end{itemize}

\devicenormative{\paragraph}{Revision Compatibility}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Versioning and Forward Compatibility / Device}
\begin{itemize}
  \item A device that advertises transport revision $N$ MUST implement all
        mandatory device behavior defined for revisions $1$ through $N$.
  \item If a device receives a driver request that relies on an unsupported
        revision or transport feature, it MUST reject the request using the
        message-specific error mechanism (if any) or silently ignore it.
\end{itemize}

\busnormative{\paragraph}{Revision Compatibility}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Versioning and Forward Compatibility / Bus}
\begin{itemize}
  \item A bus instance that advertises transport revision $N$ MUST satisfy every
        bus requirement defined for revisions $1$ through $N$.
  \item If a bus instance cannot forward a message because it requires an
        unsupported revision or transport feature, it MUST surface a transport
        error or drop the message without forwarding it.
\end{itemize}

\subsubsection{Device Numbers and Enumeration}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts /
Device Numbers}

Each virtio-msg bus instance contains one or more \emph{devices}, identified
by a 16-bit \textbf{device number}. Buses discover these device numbers through
mechanisms such as:
\begin{itemize}
  \item \textbf{Message-Based Enumeration}: Using \busref{GET_DEVICES} to query
        which numbers exist (optional).
  \item \textbf{Platform Data}: A device tree, ACPI tables, or hypervisor calls
        might inform the bus of available device numbers and their properties.
\end{itemize}

Once a bus confirms that a device number is valid—regardless of the discovery
method—it normally issues \msgref{GET_DEVICE_INFO} to retrieve the device and
vendor IDs before registering the device with the host OS so the usual Virtio
driver binding process can begin.

\busnormative{\paragraph}{Device Number Assignment}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Device Numbers / Assignment}
\begin{itemize}
  \item A bus implementation MUST assign a unique device number to every
        device on a given bus instance and MUST NOT forward transport messages
        for a device number that has not been validated.
  \item A bus implementation SHOULD provide the driver with sufficient
        information—either via \busref{GET_DEVICES} or equivalent platform
        data—to discover each valid device number.
\end{itemize}

\subsubsection{Configuration Generation Count}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts / ConfigGen}

Each device maintains a \textbf{Configuration Generation Count} to prevent
inconsistent updates. This count is incremented at least once by the device for
every driver-visible change it makes to its configuration data. The current
count is exposed in \msgref{EVENT_CONFIG} and \msgref{GET_CONFIG} responses so
the driver can determine whether its view of the configuration is current. The
count does not necessarily start at zero and is not automatically reset when
the device resets.

\devicenormative{\paragraph}{Configuration Generation Count (Device)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / ConfigGen / Device}
\begin{itemize}
  \item A device MUST increment the generation count before it makes a change
        that is visible to the driver and MUST ensure that each
        \msgref{EVENT_CONFIG} carrying configuration data uses a unique
        generation count.
  \item If updated configuration data cannot fit in a single
        \msgref{EVENT_CONFIG}, the device SHOULD send an \msgref{EVENT_CONFIG}
        with zero data length to advertise the new generation count and MUST
        make the updated data available via \msgref{GET_CONFIG}.
  \item If a \msgref{SET_CONFIG} request includes a generation count that does
        not match the device's current count, the device MUST reject the
        request.
\end{itemize}

\drivernormative{\paragraph}{Configuration Generation Count (Driver)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / ConfigGen / Driver}
\begin{itemize}
  \item A driver MUST track the most recent generation count observed (via
        \msgref{EVENT_CONFIG} or \msgref{GET_CONFIG}) and include it in every
        \msgref{SET_CONFIG} request.
  \item If a \msgref{SET_CONFIG} request is rejected due to a mismatched
        generation count, the driver SHOULD issue \msgref{GET_CONFIG} to obtain
        the latest configuration data and generation count before retrying.
\end{itemize}

This mechanism ensures updates are not lost or overwritten due to stale
information.

\subsubsection{Feature Negotiation Blocks}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts / FeatureBlocks}

The virtio-msg transport organizes feature bits into 32-bit blocks accessed by
\msgref{GET_DEVICE_FEATURES} and \msgref{SET_DRIVER_FEATURES}. Each block
represents up to 32 feature bits:

\begin{itemize}
  \item \textbf{Block Index}: The starting block (e.g., block 0 for
        features 0--31, block 1 for features 32--63, etc.).
  \item \textbf{Number of Blocks}: How many blocks the driver wishes to retrieve
        or modify in a single message.
  \item \textbf{Feature Data}: The 32-bit values representing the supported (or
        driver-requested) feature bits in the selected blocks.
\end{itemize}

\devicenormative{\paragraph}{Feature Blocks (Device)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / FeatureBlocks / Device}
\begin{itemize}
  \item When \msgref{GET_DEVICE_FEATURES} covers blocks that extend beyond the
        features a device implements, the device MUST return zero for the
        feature data in those positions.
\end{itemize}

\subsubsection{Error Signaling}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts / ErrorSignaling}

Transport errors can arise from malformed messages, routing failures inside a
bus implementation, or device-side faults while processing a valid request.
Implementations should handle such faults locally where possible, but a bus may
surface an error to the virtio-msg transport if it cannot deliver a request or
obtain a response within its policy.

\busnormative{\paragraph}{Error Handling (Bus)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / ErrorSignaling / Bus}
\begin{itemize}
  \item A bus implementation MAY report a transport-visible failure (for
        example, after exhausting a bounded retry policy) when it cannot deliver
        a request or obtain a response.
  \item A bus implementation MUST treat malformed headers or unsupported
        \field{msg_id} values as invalid, MUST discard them without generating
        additional protocol traffic, and MAY log the condition for diagnostics.
  \item A bus implementation MUST NOT generate error responses to event
        (one-way) messages.
\end{itemize}

\devicenormative{\paragraph}{Error Handling (Device)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / ErrorSignaling / Device}
\begin{itemize}
  \item A device receiving a malformed or unsupported transport message MUST
        discard it without producing further protocol traffic.
  \item Recovery actions taken in response to an error (such as retries,
        selective resets, or device removal) MUST follow the normative reset and
        status semantics defined in
        \ref{sec:Virtio Transport Options / Virtio Over Messages / Device Operation}.
\end{itemize}

This specification does not define a dedicated error-reporting message; it only
permits implementations to surface failures when silent recovery is not
feasible.

\subsubsection{Endianness}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts / Endianness}

Unless otherwise stated, all numeric fields defined for virtio-msg messages use
little-endian encoding.

\drivernormative{\paragraph}{Endianness (Driver)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Endianness / Driver}
\begin{itemize}
  \item A driver MUST encode and decode the common header and payload fields
        defined by this transport using little-endian byte order.
\end{itemize}

\devicenormative{\paragraph}{Endianness (Device)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Endianness / Device}
\begin{itemize}
  \item A device MUST emit and consume the common header and payload fields
        defined by this transport using little-endian byte order.
\end{itemize}

\subsubsection{Common Message Format}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts / Common Message Format}

All virtio-msg exchanges, whether \emph{bus messages} or \emph{transport
messages}, begin with an 8-byte header followed by an optional payload. The
fields below describe the wire format for that header.

The header layout is:
\begin{lstlisting}
struct virtio_msg_header {
    u8       type;      /* request/response + bus/transport */
    u8       msg_id;    /* message id */
    le16     dev_num;   /* device number (0 for bus messages) */
    le16     token;     /* correlation identifier (0 for events) */
    le16     msg_size;  /* total size: header (8) + payload */
    u8       payload[];
};
\end{lstlisting}

Field semantics:
\begin{itemize}
  \item \field{type}:
    \begin{itemize}
  \item Bit[0]: 0=request, 1=response.
  \item Bit[1]: 0=transport message, 1=bus message.
  \item Bits[2..7]: reserved for future use.
    \end{itemize}
  \item \field{msg_id}: Message ID identifying the message definition. Ranges
    are defined in
    \ref{sec:Virtio Transport Options / Virtio Over Messages / Transport Messages}
    and
    \ref{sec:Virtio Transport Options / Virtio Over Messages / Bus Messages}.
  \item \field{dev_num}: For transport messages, the device number that should
    receive the message. Bus messages operate on device number 0.
  \item \field{token}: Requests use non-zero tokens so responses can be matched;
    event (one-way) messages use token 0 and do not expect a response.
  \item \field{msg_size}: Total size in bytes of the complete message (header
    plus payload).
  \item \field{payload}: Operation-specific data. If a bus introduces extra
    padding bytes, those bytes are not part of the payload semantics.
\end{itemize}

\drivernormative{\paragraph}{Common Header (Driver)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Common Message Format / Driver}
\begin{itemize}
  \item A driver MUST set bits 2..7 of \field{type} to zero and MUST treat them
        as reserved when parsing received headers.
  \item A driver MUST ensure \field{msg_size} reflects the total message length
        (header plus payload) and MUST NOT exceed the maximum message size
        advertised by the bus instance.
  \item A driver MUST set \field{token}=0 for event (one-way) messages and MUST
        assign a non-zero \field{token} for every request that expects a
        response.
  \item When sending a transport message, a driver MUST set \field{dev_num} to
        the intended device number.
  \item If a driver introduces padding bytes that become part of the transport
        payload, it MUST set those bytes to zero.
\end{itemize}

\devicenormative{\paragraph}{Common Header (Device)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Common Message Format / Device}
\begin{itemize}
  \item A device MUST set bits 2..7 of \field{type} to zero in transmitted
        messages and MUST ignore those bits on receive.
  \item A device MUST ensure \field{msg_size} reflects the total message length
        (header plus payload) and does not exceed the bus's advertised maximum.
  \item A device MUST set \field{token}=0 for event (one-way) messages it
        originates and MUST echo the \field{token} received in requests when
        producing responses.
  \item When sending a transport message, a device MUST set \field{dev_num} to
        its own device number.
  \item A device MUST ignore padding bytes that are documented as bus-specific
        and MUST zero any such bytes it introduces into the transport payload.
\end{itemize}

\busnormative{\paragraph}{Common Header (Bus)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Common Message Format / Bus}
\begin{itemize}
  \item A bus implementation MUST deliver bus messages with \field{dev_num}=0
        and MUST NOT alter \field{dev_num} for transport messages beyond the
        routing needed to reach the addressed device.
  \item A bus implementation MUST set bits 2..7 of \field{type} to zero when
        generating bus messages and MUST ignore those bits when forwarding
        transport messages.
  \item If the bus adds framing or padding bytes around the common header or
        payload, it MUST set those bytes to zero before delivering the message
        to the opposite side and MUST present the same zero padding when the
        opposite side reads a message.
\end{itemize}

Reserved header bits and unspecified header values MUST be transmitted as zero
and ignored on receive to preserve forward compatibility.

\subsubsection{Message Correlation}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts / Correlation}

Requests expect responses, whereas events are one-way and do not. Correlation is
based on the tuple (\field{dev_num}, \field{token}) from the message header.

\drivernormative{\paragraph}{Message Correlation (Driver)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Correlation / Driver}
\begin{itemize}
  \item A driver MUST assign a non-zero \field{token} for each outstanding
        request so that the (\field{dev_num}, \field{token}) tuple remains
        unique among inflight requests.
  \item A driver MUST set \field{token}=0 when sending event (one-way) messages
        and MUST ignore any error responses purportedly referencing such events.
  \item When processing responses, a driver SHOULD discard any response whose
        correlation tuple does not match an outstanding request.
\end{itemize}

\devicenormative{\paragraph}{Message Correlation (Device)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Correlation / Device}
\begin{itemize}
  \item A device MUST echo the \field{token} and \field{dev_num} from the
        corresponding request when generating a response.
  \item A device MUST set \field{token}=0 when generating event (one-way)
        messages and MUST NOT send error responses referencing those events.
  \item A device SHOULD discard responses from the other side that reference a
        correlation tuple that is unknown or already completed.
\end{itemize}

\subsection{Device Discovery}\label{sec:Virtio Transport Options / Virtio Over Messages / Device Discovery}

A virtio-msg implementation can learn about devices via bus-level enumeration
(e.g., \busref{GET_DEVICES}), platform data (e.g., device tree, ACPI), or
hypervisor/firmware interfaces. The following informative text describes
typical flows; the normative obligations follow.

Bus implementations discover their devices through a mix of platform data,
hypervisor-provided enumeration, or message-based queries such as
\busref{GET_DEVICES}. This specification defines \busref{GET_DEVICES} for
environments that prefer message-driven enumeration, but it does not require
its use when equivalent information is already known out-of-band.

\busnormative{\paragraph}{Device Discovery (Bus)}{Virtio Transport Options / Virtio Over Messages / Device Discovery / Bus}
\begin{itemize}
  \item A bus implementation MUST ensure that every device number it exposes to
        the driver has been validated via either platform data or a successful
        query such as \busref{GET_DEVICES}.
  \item Once a device number is deemed present, the bus implementation SHOULD
        invoke \msgref{GET_DEVICE_INFO} so it can register the device with the
        host OS and allow the appropriate virtio driver to bind.
  \item If a bus implementation provides an alternative enumeration mechanism
        (e.g., ACPI, device tree), it MAY omit \busref{GET_DEVICES} provided the
        alternative delivers equivalent information to the driver.
\end{itemize}

\subsection{Device Initialization}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization}

After a bus has identified a virtio-msg device (whether by message-based
enumeration or platform-specific discovery), the driver undertakes a series of
steps to configure and ready the device for normal operation. This section
details the recommended order of operations and the associated messages.

\subsubsection{Initialization Flow Overview}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization / Overview}

A typical device initialization flow includes:
\begin{enumerate}
  \item \textbf{Obtain Device Information:}
    Query static parameters with \msgref{GET_DEVICE_INFO}.
  \item \textbf{Negotiate Features:}
    Read feature blocks via \msgref{GET_DEVICE_FEATURES}, decide which to
    enable, and write them back with \msgref{SET_DRIVER_FEATURES} before
    updating the device status.
  \item \textbf{Initialize Configuration Space:}
    Read or write configuration data with
    \msgref{GET_CONFIG}/\msgref{SET_CONFIG}, guarding updates with the
    configuration generation count.
  \item \textbf{Set Up Virtqueues:}
    Configure each virtqueue via \msgref{SET_VQUEUE} and verify the settings
    with \msgref{GET_VQUEUE}.
  \item \textbf{Set Device Status:}
    Use \msgref{SET_DEVICE_STATUS} to drive the device through the standard
    virtio status states.
\end{enumerate}

The exact order may vary slightly across implementations, but these steps form
the baseline for virtio-msg initialization.

\drivernormative{\paragraph}{Initialization Flow (Driver)}{Virtio Transport Options / Virtio Over Messages / Device Initialization / Overview / Driver}
\begin{itemize}
  \item A driver MUST issue \msgref{GET_DEVICE_INFO} before attempting feature
        negotiation or queue setup.
  \item A driver MUST complete feature negotiation via
        \msgref{GET_DEVICE_FEATURES}/\msgref{SET_DRIVER_FEATURES}
        and confirm the FEATURES\_OK state via \msgref{SET_DEVICE_STATUS} before
        enabling virtqueues.
  \item A driver MUST configure each virtqueue via \msgref{SET_VQUEUE} and
        confirm its parameters (e.g., with \msgref{GET_VQUEUE}) before marking
        the queue ready for I/O.
  \item A driver MUST drive the device status transitions using
        \msgref{SET_DEVICE_STATUS}, ensuring the device reaches DRIVER\_OK
        before issuing normal I/O.
\end{itemize}

\subsubsection{Device Information}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization / Device Information}

Once a device number is confirmed, the driver uses \msgref{GET_DEVICE_INFO} to
retrieve static identification data (device ID, vendor ID), the number of
feature bits, configuration space size, maximum virtqueues, shared memory
segments, and any admin virtqueue details. This information determines which
virtio driver should bind to the device, how many feature blocks to query, and
how much configuration space is valid.

\drivernormative{\paragraph}{Device Information (Driver)}{Virtio Transport Options / Virtio Over Messages / Device Initialization / Device Information / Driver}
\begin{itemize}
  \item A driver MUST issue \msgref{GET_DEVICE_INFO} before attempting feature
        negotiation or queue setup so it can discover the device ID, vendor ID,
        feature count, configuration size, and virtqueue limits.
  \item A driver MUST use the configuration size reported via
        \msgref{GET_DEVICE_INFO} to bound any offsets and lengths supplied in
        \msgref{GET_CONFIG} and \msgref{SET_CONFIG} requests.
\end{itemize}

\subsubsection{Feature Negotiation}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization / Device Features}

Drivers read available features in 32-bit blocks using
\msgref{GET_DEVICE_FEATURES}; the device returns the requested bitfields,
padding with zeros for any out-of-range blocks. To enable selected features, the
driver writes them back with \msgref{SET_DRIVER_FEATURES} and then updates the
device status via \msgref{SET_DEVICE_STATUS}, checking whether the FEATURES\_OK
bit remains set.

\drivernormative{\paragraph}{Feature Negotiation (Driver)}{Virtio Transport Options / Virtio Over Messages / Device Initialization / Device Features / Driver}
\begin{itemize}
  \item A driver MUST use \msgref{GET_DEVICE_FEATURES} to discover the feature
        bits offered by the device and MUST write back only the features it
        intends to enable via \msgref{SET_DRIVER_FEATURES}.
  \item After writing the desired features, the driver MUST attempt to set the
        FEATURES\_OK bit using \msgref{SET_DEVICE_STATUS} and MUST check the
        returned status to ensure the device accepted the set.
\end{itemize}

\devicenormative{\paragraph}{Feature Negotiation (Device)}{Virtio Transport Options / Virtio Over Messages / Device Initialization / Device Features / Device}
\begin{itemize}
  \item When handling \msgref{GET_DEVICE_FEATURES}, a device MUST return zero
        for any requested bits that fall outside the number of feature bits it
        implements.
  \item After receiving \msgref{SET_DRIVER_FEATURES}, a device MUST update its
        internal feature mask to match the acknowledged set and MUST reflect
        acceptance or rejection by leaving the FEATURES\_OK bit set or clearing
        it in the status returned by \msgref{SET_DEVICE_STATUS}.
\end{itemize}

\subsubsection{Device Configuration}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization / Device Configuration}

Drivers use \msgref{GET_CONFIG} to read portions of the configuration space by
supplying an offset and length; the device returns the requested data plus the
current configuration generation count. Writing is performed via
\msgref{SET_CONFIG}, which carries the same offset/length along with the
driver's notion of the generation count and the new data.

\drivernormative{\paragraph}{Device Configuration (Driver)}{Virtio Transport Options / Virtio Over Messages / Device Initialization / Device Configuration / Driver}
\begin{itemize}
  \item A driver MUST ensure that the offset and length in each
        \msgref{GET_CONFIG} or \msgref{SET_CONFIG} request stay within the
        configuration size reported by \msgref{GET_DEVICE_INFO}.
  \item A driver MUST include its most recently observed configuration
        generation count in a \msgref{SET_CONFIG} request and SHOULD re-read the
        configuration (via \msgref{GET_CONFIG}) if the request is rejected for a
        generation mismatch.
\end{itemize}

\devicenormative{\paragraph}{Device Configuration (Device)}{Virtio Transport Options / Virtio Over Messages / Device Initialization / Device Configuration / Device}
\begin{itemize}
  \item A device MUST reject a \msgref{SET_CONFIG} request whose generation
        count does not match its current value and MUST indicate the rejection
        in the response.
  \item A device MUST return the current configuration generation count
        alongside any data returned via \msgref{GET_CONFIG}.
\end{itemize}

\subsubsection{Virtqueue Configuration}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization / Virtqueue Configuration}

Drivers query virtqueue parameters with \msgref{GET_VQUEUE}, configure them via
\msgref{SET_VQUEUE}, and optionally reset them using \msgref{RESET_VQUEUE} (if
VIRTIO\_F\_RING\_RESET is negotiated). Each queue is typically configured by
reading its maximum size, provisioning descriptor/available/used buffers, and
then calling \msgref{SET_VQUEUE} with the chosen size and guest-physical
addresses.

\drivernormative{\paragraph}{Virtqueue Configuration (Driver)}{Virtio Transport Options / Virtio Over Messages / Device Initialization / Virtqueue Configuration / Driver}
\begin{itemize}
  \item A driver MUST use \msgref{GET_VQUEUE} to determine the maximum queue
        size and confirm that a queue is inactive before programming it.
  \item A driver MUST ensure the queue size provided in \msgref{SET_VQUEUE} does
        not exceed the maximum reported by the device and MUST supply valid
        descriptor/driver/device addresses before enabling the queue.
  \item If VIRTIO\_F\_RING\_RESET has been negotiated and a queue requires
        reinitialization, the driver SHOULD use \msgref{RESET_VQUEUE} before
        reprogramming it.
\end{itemize}

\devicenormative{\paragraph}{Virtqueue Configuration (Device)}{Virtio Transport Options / Virtio Over Messages / Device Initialization / Virtqueue Configuration / Device}
\begin{itemize}
  \item A device MUST report accurate maximum queue sizes in \msgref{GET_VQUEUE}
        and MUST persist the parameters supplied via \msgref{SET_VQUEUE} (size,
        descriptor, driver, and device addresses).
  \item When \msgref{RESET_VQUEUE} is issued (and VIRTIO\_F\_RING\_RESET is
        negotiated), the device MUST quiesce the queue, release any resources
        associated with it, and allow the driver to reconfigure it.
\end{itemize}

\subsubsection{Status Information}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization / Status Information}

Drivers query the device status via \msgref{GET_DEVICE_STATUS} to observe
progress or detect errors, and they drive the Virtio status transitions via
\msgref{SET_DEVICE_STATUS}. Writing zero to the status field resets the device,
invalidating any configuration or virtqueue state.

\drivernormative{\paragraph}{Status Handling (Driver)}{Virtio Transport Options / Virtio Over Messages / Device Initialization / Status Information / Driver}
\begin{itemize}
  \item A driver SHOULD read the device status via \msgref{GET_DEVICE_STATUS}
        when diagnosing errors or determining whether the device is ready to
        move to the next initialization phase.
  \item A driver MUST use \msgref{SET_DEVICE_STATUS} to drive the device through
        the virtio-defined status states and MUST write 0 to request a device
        reset when needed.
\end{itemize}

\devicenormative{\paragraph}{Status Handling (Device)}{Virtio Transport Options / Virtio Over Messages / Device Initialization / Status Information / Device}
\begin{itemize}
  \item Upon receiving a \msgref{SET_DEVICE_STATUS} write of 0, a device MUST
        reset its internal state, invalidate existing configuration and
        virtqueue settings, and present the status field as 0.
  \item A device MUST report its current status accurately via
        \msgref{GET_DEVICE_STATUS}, including whether the FEATURES\_OK bit has
        been accepted or cleared.
\end{itemize}

\subsubsection{Finalizing Initialization}

After configuring virtqueues and agreeing on features, the driver transitions
the device to DRIVER\_OK (and any other required status bits) via
\msgref{SET_DEVICE_STATUS}. At that point, the device is considered ready for
normal virtqueue I/O.

\drivernormative{\paragraph}{Final Status (Driver)}{Virtio Transport Options / Virtio Over Messages / Device Initialization / Finalizing Initialization / Driver}
\begin{itemize}
  \item A driver MUST set DRIVER\_OK via \msgref{SET_DEVICE_STATUS} only after
        it has completed feature negotiation and initialized all required
        virtqueues.
  \item A driver MUST NOT queue normal I/O until the device reports a status
        that includes DRIVER\_OK.
  \item A driver MUST NOT supply buffers or send driver notifications for a
        virtqueue until that queue has been configured via \msgref{SET_VQUEUE}.
\end{itemize}

\devicenormative{\paragraph}{Final Status (Device)}{Virtio Transport Options / Virtio Over Messages / Device Initialization / Finalizing Initialization / Device}
\begin{itemize}
  \item A device MUST NOT process normal virtqueue I/O until the driver has set
        DRIVER\_OK.
  \item Once DRIVER\_OK is set, the device MUST begin processing virtqueue
        requests subject to the negotiated features and queue configurations.
\end{itemize}

\subsection{Device Operation}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Operation}

Once a virtio-msg device is fully initialized (see
\ref{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization}),
the driver and device exchange messages to perform I/O and respond to
configuration changes. This section details the primary messaging paths for
\emph{driver notifications}, \emph{device notifications}, and the handling of
runtime resets or shutdown sequences.

\subsubsection{Driver Notifications}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Operation / Driver Notifications}

After buffers are made available to a virtqueue, the driver issues
\msgref{EVENT_AVAIL} to notify the device. A bus implementation may translate
these notifications into an out-of-band mechanism or deliver them in-band.

\drivernormative{\paragraph}{Driver Notifications (Driver)}{Virtio Transport Options / Virtio Over Messages / Device Operation / Driver Notifications / Driver}
\begin{itemize}
  \item A driver MUST send \msgref{EVENT_AVAIL} when it places new buffers on a
        virtqueue.
  \item Each \msgref{EVENT_AVAIL} MUST identify the target virtqueue index.
  \item If VIRTIO\_F\_NOTIFICATION\_DATA has been negotiated, the driver MUST
        populate the “next offset and wrap” fields so the device can locate the
        head of the updated ring; otherwise those fields MUST be zero.
\end{itemize}

\busnormative{\paragraph}{Driver Notifications (Bus)}{Virtio Transport Options / Virtio Over Messages / Device Operation / Driver Notifications / Bus}
\begin{itemize}
  \item A bus implementation MAY convert \msgref{EVENT_AVAIL} into an
        out-of-band notification but, if it does not, it MUST relay the message
        over the virtio-msg channel.
  \item A bus implementation MUST NOT drop \msgref{EVENT_AVAIL} unless it has
        arranged for the device to detect new buffers through polling or an
        equivalent mechanism.
\end{itemize}

\subsubsection{Device Notifications}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Operation / Device Notifications}

\msgref{EVENT_CONFIG} and \msgref{EVENT_USED} provide asynchronous notifications
from the device (or device-side bus) to the driver. The bus may forward these
messages in-band or synthesize them based on other signals such as interrupts
or polling.

\devicenormative{\paragraph}{Device Notifications (Device)}{Virtio Transport Options / Virtio Over Messages / Device Operation / Device Notifications / Device}
\begin{itemize}
  \item A device (or device-side bus) MUST send \msgref{EVENT_CONFIG} whenever
        it makes a configuration change or status update that becomes visible to
        the driver. The message MUST include the new configuration generation
        count and MAY include the updated configuration data.
  \item If the configuration data is omitted from \msgref{EVENT_CONFIG}, the
        device SHOULD include the relevant offsets/lengths so the driver can
        re-fetch the data via \msgref{GET_CONFIG}.
  \item A device SHOULD send \msgref{EVENT_USED} to inform the driver when
        buffers on a virtqueue have been consumed, unless the device relies on
        an alternative, agreed-upon completion mechanism.
\end{itemize}

\drivernormative{\paragraph}{Device Notifications (Driver)}{Virtio Transport Options / Virtio Over Messages / Device Operation / Device Notifications / Driver}
\begin{itemize}
  \item Upon receiving \msgref{EVENT_CONFIG}, a driver SHOULD update its view of
        the configuration using the provided data (or by issuing
        \msgref{GET_CONFIG} if necessary) before resuming normal I/O.
  \item Upon receiving \msgref{EVENT_USED}, a driver MUST examine the indicated
        virtqueue (for example, by reading the used ring) to reclaim completed
        buffers.
\end{itemize}

\busnormative{\paragraph}{Device Notifications (Bus)}{Virtio Transport Options / Virtio Over Messages / Device Operation / Device Notifications / Bus}
\begin{itemize}
  \item A bus implementation MUST forward \msgref{EVENT_CONFIG} and
        \msgref{EVENT_USED} notifications (or their equivalents) to the driver,
        either in-band or by synthesizing the appropriate message.
  \item If a bus implementation relies on polling or other mechanisms instead of
        direct notifications, it SHOULD limit that mode to scenarios where no
        other notification method is available.
\end{itemize}

\subsubsection{Configuration Changes During Operation}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Operation / ConfigUpdates}

Drivers may update configuration fields at runtime using \msgref{SET_CONFIG}
when features such as device modes or limits need to change. Devices can also
update configuration data autonomously but must signal those changes via
\msgref{EVENT_CONFIG}.

\drivernormative{\paragraph}{Runtime Configuration (Driver)}{Virtio Transport Options / Virtio Over Messages / Device Operation / ConfigUpdates / Driver}
\begin{itemize}
  \item A driver MAY issue \msgref{SET_CONFIG} after initialization, provided it
        includes the current configuration generation count and follows the same
        validation rules as during setup.
  \item Upon receiving an \msgref{EVENT_CONFIG}, the driver SHOULD refresh its
        view of the configuration (via the data provided or by reissuing
        \msgref{GET_CONFIG}) before relying on the updated values.
\end{itemize}

\devicenormative{\paragraph}{Runtime Configuration (Device)}{Virtio Transport Options / Virtio Over Messages / Device Operation / ConfigUpdates / Device}
\begin{itemize}
  \item If a device updates its configuration after initialization, it MUST send
        \msgref{EVENT_CONFIG} to inform the driver of the change and provide the
        new configuration generation count.
\end{itemize}

\subsubsection{Virtqueue Changes During Operation}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Operation / VQueueUpdates}

Drivers may provision unused virtqueues later in the device lifetime by issuing
\msgref{SET_VQUEUE}, and they may reconfigure existing queues if the
VIRTIO\_F\_RING\_RESET feature has been negotiated.

\drivernormative{\paragraph}{Runtime Virtqueue Changes (Driver)}{Virtio Transport Options / Virtio Over Messages / Device Operation / VQueueUpdates / Driver}
\begin{itemize}
  \item A driver MAY configure additional virtqueues after initialization using
        \msgref{SET_VQUEUE}, provided it follows the same validation steps
        (e.g., checking the maximum queue size).
  \item If VIRTIO\_F\_RING\_RESET is negotiated, the driver SHOULD use
        \msgref{RESET_VQUEUE} before reprogramming a queue to avoid races with
        the device.
\end{itemize}

\devicenormative{\paragraph}{Runtime Virtqueue Changes (Device)}{Virtio Transport Options / Virtio Over Messages / Device Operation / VQueueUpdates / Device}
\begin{itemize}
  \item A device MUST honor \msgref{SET_VQUEUE} requests issued after
        initialization and update the queue parameters accordingly.
  \item When \msgref{RESET_VQUEUE} is received (and VIRTIO\_F\_RING\_RESET is
        negotiated), the device MUST quiesce the queue and allow the driver to
        reconfigure it without processing stale data.
\end{itemize}

\subsubsection{Device Reset and Shutdown}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Operation / Reset}

Drivers reset a device by writing 0 to the status field via \msgref{SET_DEVICE_STATUS},
which forces the device to discard pending operations and return to the initial state.
A device may also signal that a reset is required by sending \msgref{EVENT_CONFIG}
with the DEVICE\_NEEDS\_RESET bit set.

\drivernormative{\paragraph}{Reset and Shutdown (Driver)}{Virtio Transport Options / Virtio Over Messages / Device Operation / Reset / Driver}
\begin{itemize}
  \item A driver MAY request a device reset at any time by writing 0 through
        \msgref{SET_DEVICE_STATUS} and MAY reinitialize the device afterwards if
        it intends to resume operation.
  \item If a device signals DEVICE\_NEEDS\_RESET (for example, via
        \msgref{EVENT_CONFIG}), the driver SHOULD write 0 to
        \msgref{SET_DEVICE_STATUS} and reinitialize the device before resuming
        I/O.
\end{itemize}

\devicenormative{\paragraph}{Reset and Shutdown (Device)}{Virtio Transport Options / Virtio Over Messages / Device Operation / Reset / Device}
\begin{itemize}
  \item Upon receiving a \msgref{SET_DEVICE_STATUS} write of 0, a device MUST
        reset its internal state, discard pending virtqueue operations, and
        present the status field as 0.
  \item If the device encounters an unrecoverable error that requires driver
        intervention, it SHOULD signal DEVICE\_NEEDS\_RESET (such as via
        \msgref{EVENT_CONFIG}) so the driver can initiate a reset.
\end{itemize}

\subsubsection{Hotplug and Removal}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Operation / Hotplug and Removal}

If the bus supports dynamic addition or removal of devices, it can advertise
those changes with \busref{EVENT_DEVICE} (READY or REMOVED). Some platforms may
instead rely on external signals such as ACPI, device tree updates, or
hypervisor events; virtio-msg does not mandate a specific mechanism.

\busnormative{\paragraph}{Hotplug and Removal (Bus)}{Virtio Transport Options / Virtio Over Messages / Device Operation / Hotplug and Removal / Bus}
\begin{itemize}
  \item A bus implementation that uses \busref{EVENT_DEVICE} MUST send the READY
        event when a device becomes accessible and the REMOVED event when it is
        no longer available.
  \item Regardless of how hotplug information is delivered, once a new device is
        reported the bus SHOULD query it (e.g., via \msgref{GET_DEVICE_INFO})
        and register it with the host OS. When a device is removed, the bus
        SHOULD prompt the OS to quiesce and release the associated driver.
\end{itemize}

\subsection{Transport Messages}\label{sec:Virtio Transport Options / Virtio Over Messages / Transport Messages}

Transport messages are used to configure and operate individual virtio devices.
Unlike bus messages (which handle device enumeration, hotplug, or global resets),
transport messages MUST be implemented by any virtio-msg device and
driver pair to enable standard virtio functionality (feature negotiation,
configuration, virtqueues, etc.). The subsections below describe each message
and clarify its required fields, typical usage patterns, and possible responses.

\subsubsection{Overview}
\label{sec:Virtio Transport Options / Virtio Over Messages / Transport Messages / Overview}

A driver typically sends these messages to a known device number,
and the virtio-msg device responds or notifies as appropriate. The
bus \emph{forwards} these messages but does not interpret or modify them beyond
basic checks (e.g., ensuring the size does not exceed the maximum size
supported, verifying the target device number exists).

Most transport messages adopt a \emph{request/response} pattern, but some are
unidirectional (e.g., asynchronous notifications).

\paragraph{Messages IDs and issuers}

\begin{tabular}{|l|l|l|}
\hline
Name & ID & Sender \\
\hline
\hline
Reserved                   & 0x0 & \\
\hline
Reserved                   & 0x1 & \\
\hline
\msgref{GET_DEVICE_INFO}   & 0x2  & Driver \\
\hline
\msgref{GET_DEVICE_FEATURES} & 0x3  & Driver \\
\hline
\msgref{SET_DRIVER_FEATURES} & 0x4  & Driver \\
\hline
\msgref{GET_CONFIG}        & 0x5  & Driver \\
\hline
\msgref{SET_CONFIG}        & 0x6  & Driver \\
\hline
\msgref{GET_DEVICE_STATUS} & 0x7  & Driver \\
\hline
\msgref{SET_DEVICE_STATUS} & 0x8  & Driver \\
\hline
\msgref{GET_VQUEUE}        & 0x9  & Driver \\
\hline
\msgref{SET_VQUEUE}        & 0xA  & Driver \\
\hline
\msgref{RESET_VQUEUE}      & 0xB  & Driver \\
\hline
\msgref{GET_SHM}           & 0xC  & Driver \\
\hline
\msgref{EVENT_CONFIG}      & 0x40 & Device \\
\hline
\msgref{EVENT_AVAIL}       & 0x41 & Driver \\
\hline
\msgref{EVENT_USED}        & 0x42 & Device \\
\hline
\end{tabular}

Transport message IDs 0x00 to 0x3F are used for messages that require a response
and IDs 0x40 to 0x7F are used for event messages. Transport message IDs 0x80
and above are reserved by this specification.

\paragraph{Mandatory Transport Messages}
For a virtio-msg device to be fully operational, the following messages
MUST be supported:
\begin{itemize}
  \item \msgref{GET_DEVICE_INFO}
  \item \msgref{GET_DEVICE_FEATURES} and \msgref{SET_DRIVER_FEATURES}
  \item \msgref{GET_CONFIG} and \msgref{SET_CONFIG}
  \item \msgref{GET_DEVICE_STATUS} and \msgref{SET_DEVICE_STATUS}
  \item \msgref{GET_VQUEUE}, \msgref{SET_VQUEUE}, and \msgref{RESET_VQUEUE}
\end{itemize}

The functionality of the following messages MUST be provided by
in-band messages, out-of-band event notification, or bus implementation based
polling:
\begin{itemize}
  \item \msgref{EVENT_AVAIL}
  \item \msgref{EVENT_USED}
  \item \msgref{EVENT_CONFIG}
\end{itemize}

\msgdef{GET_DEVICE_INFO}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 0 & None \\
\hline
Answer & 0 & 4 & Device ID \\
& 4 & 4 & Vendor ID \\
& 8 & 4 & Number of feature bits \\
& 12 & 4 & Configuration size in bytes \\
& 16 & 4 & Maximum number of virtqueues \\
& 20 & 2 & Admin virtqueue start index \\
& 22 & 2 & Admin virtqueue count \\
\hline
\end{tabular}

The number of feature bits MUST be a multiple of 32.

This is the only message allowed for an inactive device. If this message queries
an inactive device all fields in the response SHOULD be 0.

\msgdef{GET_DEVICE_FEATURES}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Feature block index \\
& 4 & 4 & Number of feature blocks \\
\hline
Answer & 0 & 4 & Feature block index \\
& 4 & 4 & Number of feature blocks \\
& 8 & ... & Feature data \\
\hline
\end{tabular}

A feature block is a group of 32 bits.  The feature data MUST be a
multiple of 4 bytes in length.

\msgdef{SET_DRIVER_FEATURES}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Feature block index \\
& 4 & 4 & Number of feature blocks \\
& 8 & ... & Feature data \\
\hline
Answer & 0 & 0 & no extra data \\
\hline
\end{tabular}

A feature block is a group of 32 bits.  The feature data MUST be a
multiple of 4 bytes in length.

Note: As defined in \ref{sec:Basic Facilities of a Virtio Device / Feature Bits},
if the device is not OK with the features set, it MUST not allow
the FEATURES_OK bit in the device status to be set.

\msgdef{GET_CONFIG}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Configuration offset in bytes \\
& 4 & 4 & Number of bytes \\
\hline
Answer & 0 & 4 & Configuration generation count \\
& 4 & 4 & Configuration offset in bytes \\  \\
& 8 & 4 & Number of bytes \\
& 12 & ... & Configuration data \\
\hline
\end{tabular}

\msgdef{SET_CONFIG}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Configuration generation count \\
& 4 & 4 & Configuration offset in bytes \\
& 8 & 4 & Number of bytes \\
& 12 & ... & Configuration data \\
\hline
Answer & 0 & 4 & New Configuration generation count \\
& 4 & 4 & Configuration offset in bytes \\
& 8 & 4 &  Number of bytes, or 0 if rejected \\
& 12 & ... & Configuration data \\
\hline
\end{tabular}

See \ref{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization / Device Configuration}
for details about rejection and for new data not equal to written data.

\msgdef{GET_DEVICE_STATUS}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 0 & None \\
\hline
Answer & 0 & 4 & Device status \\
\hline
\end{tabular}

\msgdef{SET_DEVICE_STATUS}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Device status \\
\hline
Answer & 0 & 4 & New device status \\
\hline
\end{tabular}

The resulting device status is returned and MAY not match the status set.  The
device MAY set the DEVICE_NEEDS_RESET bit if it has an issue.  The device MAY
refuse to set the FEATURES_OK bit if it cannot operate with the features set
by the driver.

\msgdef{GET_VQUEUE}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Virtqueue index \\
\hline
Answer & 0 & 4 & Virtqueue index \\
& 4 & 4 & Maximum virtqueue size \\
& 8 & 4 & Current virtqueue size \\
& 12 & 4 & Reserved (Must Be Zero - MBZ) \\
& 16 & 8 & Descriptor address \\
& 24 & 8 & Driver address \\
& 32 & 8 & Device address \\
\hline
\end{tabular}

If the maximum virtqueue size is zero, the virtqueue is not valid and
MUST not be used.

\msgdef{SET_VQUEUE}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Virtqueue index \\
& 4 & 4 & Reserved (Must Be Zero - MBZ) \\
& 8 & 4 & Current virtqueue size \\
& 12 & 4 & Reserved (Must Be Zero - MBZ) \\
& 16 & 8 & Descriptor address \\
& 24 & 8 & Driver address \\
& 32 & 8 & Device address \\
\hline
Answer & 0 & 0 & no extra data \\
\hline
\end{tabular}

\msgdef{RESET_VQUEUE}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

The driver SHOULD NOT send this message unless the VIRTIO_F_RING_RESET
feature has been negotiated.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Virtqueue index \\
\hline
Answer & 0 & 0 & no extra data \\
\hline
\end{tabular}

\msgdef{GET_SHM}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Shared memory region index \\
\hline
Answer & 0 & 4 & Shared memory region index \\
& 4 & 4 & Shared memory region length \\
& 8 & 4 & Shared memory region address \\
\hline
\end{tabular}

If the returned shared memory region length is zero, the memory region does not
exist.

Note: these shared memory regions are device owned and supported on other virtio
transports since virtio v1.3. These shared memory regions are separate and
distinct from any shared memory regions defined by the bus implementation.

\msgdef{EVENT_CONFIG}

This message is sent by the virtio-msg device and there is no response.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Device status \\
& 4 & 4 & Configuration generation count \\
& 8 & 4 & Configuration offset \\
& 12 & 4 & Number of bytes (MAY be zero) \\
& 16 & ... & Configuration data \\
\hline
\end{tabular}

The number of bytes field MAY be zero. If so the configuration data field
will also be of zero length. This is the normal case when the configuration
generation count has not been changed.

If the number of bytes field is zero and the configuration generation count is
changed, then the driver is responsible for discovering any changed
configuration data via \msgref{GET_CONFIG} messages.

\msgdef{EVENT_AVAIL}

This message is sent by the virtio-msg driver and there is no response.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Virtqueue index \\
& 4 & 4 & Next offset and Next wrap \\
\hline
\end{tabular}

The \textbf{Next wrap} field is the MSB of the 32 bit value. The
\textbf{Next offset} field is the other 31 bits. These fields SHOULD be 0 if
the VIRTIO_F_NOTIFICATION_DATA feature has not been negotiated. If the bus
implementation is using out-of-band notifications, it SHOULD prevent this
feature from being negotiated.

\msgdef{EVENT_USED}

This message is sent by the virtio-msg device and there is no response.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Virtqueue index \\
\hline
\end{tabular}

\subsection{Bus Messages}\label{sec:Virtio Transport Options / Virtio Over Messages / Bus Messages}

The bus messages defined in this specification facilitate device discovery,
hotplug management, and liveness checks at the bus level.
They are intended for bus implementations that wish to perform these operations
\emph{via virtio-msg} rather than relying exclusively on external means (e.g.,
firmware tables, device trees). Each bus instance MAY use a subset of or
all these messages according to its design.

\subsubsection{Overview}
\label{sec:Virtio Transport Options / Virtio Over Messages / Bus Messages / Overview}

A bus implementation \textbf{is not required} to use these
messages if it already provides equivalent functionality through some
platform-specific mechanism. However, if a bus chooses to handle enumeration,
hotplug, etc. via virtio-msg, it SHOULD implement the corresponding
message definitions below.

\paragraph{Messages IDs and issuers}

\begin{tabular}{|l|l|l|}
\hline
Name & ID & Sender \\
\hline
\hline
Reserved                    & 0x0  &        \\
\hline
Reserved                    & 0x1  &        \\
\hline
\busref{GET_DEVICES}        & 0x2  & Driver \\
\hline
\busref{PING}               & 0x3  & Any    \\
\hline
\busref{EVENT_DEVICE}       & 0x40 & Device \\
\hline
\end{tabular}

Bus message IDs below 0x80 are reserved for standardized (but optional) bus
messages.  A few are used here and more are expected in the future. Bus message
IDs below 0x40 are used for request/response messages and 0x40 and above for
event messages.

Bus message IDs 0x80 and above are bus implementation specific. Bus
implementations MAY specify the policy that IDs below 0xC0 be used
for request/response messages and IDs 0xC0 and above are used for event messages.

\paragraph{Bus Specific Messages}
\label{sec:Virtio Transport Options / Virtio Over Messages / Bus Operation / Bus Specific Messages}

A range of message IDs are reserved for use by the specific bus
implementation. These messages can be used for any implementation specific
usage. Example usage could include:

\begin{itemize}
  \item Configuration of out-of-band notification methods
  \item Setup shared memory regions to be used for buffers or virtqueues
  \item Declare bus specific error conditions
  \item Provide extra debug or logging information
\end{itemize}

\busdef{GET_DEVICES}

The driver-side bus uses this request to enumerate device numbers on the
device-side bus. The response describes a “window” of device numbers and signals
which entries are present.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 2 & offset: first device number in the window \\
        & 2 & 2 & count: number of consecutive device numbers covered \\
\hline
Answer  & 0 & 2 & offset (echoed) \\
        & 2 & 2 & count actually returned \\
        & 4 & 2 & next\_offset: 0 or the start of the recommended next window \\
        & 6 & count/8 & bitmap: bit $n$ ($0 \le n <$ count) describes device number $(offset + n)$ (0=absent, 1=present) \\
\hline
\end{tabular}

\textbf{offset} and \textbf{count} MUST be multiples of 8; the bitmap length is
\textbf{count/8} and is packed LSB-first (device number \textbf{offset} is the
LSB of the first byte).
\textbf{next_offset} is either 0 (no further windows) or an aligned value
$\ge offset + count$ that the responder suggests querying next.

The \textbf{(offset, count)} tuple defines a window of \textbf{count}
consecutive device numbers beginning at \textbf{offset}. The number of present
devices equals the number of 1-bits in the bitmap. Responders SHOULD return the
requested \textbf{count} unless constrained (e.g., by maximum message size);
otherwise they MAY return a smaller value, in which case the bitmap covers the
reduced window.

Example: a request with \textbf{offset}=0, \textbf{count}=16 might produce
\textbf{bitmap}=0b00100101 00000000 and \textbf{next_offset}=16. That indicates
devices 0, 2, and 5 are present within the 0–15 window and suggests continuing
at device number 16.

\paragraph{Intended usage}
Drivers MAY use this message to enumerate device numbers. Treat each window as
a snapshot, advance using \textbf{next_offset}, and confirm candidates via
\msgref{GET_DEVICE_INFO} before issuing other transport messages.

\busdef{EVENT_DEVICE}

This message is sent by the virtio-msg device side bus and there is no response.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 2 & Device Number \\
        & 2 & 2 & Device Bus State \\
\hline
\end{tabular}

\begin{tabular}{|l|l|l|}
\hline
Device Bus State & Value & Meaning \\
\hline
\hline
DEVICE_BUS_STATE_READY      & 0x1  & Device is present and ready \\
\hline
DEVICE_BUS_STATE_REMOVED    & 0x2  & Device is no longer present \\
\hline
reserved          & 0x3 to 0x7FFF & Reserved for standard use \\
\hline
any               & 0x8000 to 0xFFFF & MAY be used by bus implementations \\
\hline
\end{tabular}

This event is sent when the bus level state of the device has changed.
It can indicate when a device is added or removed. It MAY also be used by
bus implementations to indicate other states.

\paragraph{Intended usage}
This message advertises device presence or removal. Upon READY, drivers SHOULD
probe the device via \msgref{GET_DEVICE_INFO} and proceed with initialization
if successful. Upon REMOVED, drivers MUST stop queueing new requests,
quiesce/reset as applicable, and release resources. Drivers SHOULD tolerate
duplicates and out-of-order events, and MAY use bus-level monitoring (see
\busref{PING}) to refine policy.

\busdef{PING}

This message is sent by the virtio-msg driver side bus or device side bus and
requires a response.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
 \hline \hline
Request & 0 & 4 & Data \\
\hline
Answer & 0 & 4 & Request Data \\
\hline
\end{tabular}

\paragraph{Intended usage}
Drivers MAY treat \busref{PING} as an optional keepalive or monitoring
mechanism. Timeouts or missing replies SHOULD trigger validation of device
state via \msgref{GET_DEVICE_STATUS} and recovery as appropriate.

\subsection{Compliance}
\label{sec:Virtio Transport Options / Virtio Over Messages / Compliance}

This section details the requirements that an implementation MUST meet to
be considered compliant with the virtio-msg transport. It distinguishes between
\emph{mandatory} behaviors that all implementations MUST support and
\emph{optional} behaviors that are permissible but not required.

\subsubsection{Normative References}
\label{sec:Virtio Transport Options / Virtio Over Messages / Compliance / NormativeRefs}
The terms MUST, MUST NOT, SHOULD, SHOULD NOT,
and MAY in this document are to be interpreted as specified by
\href{https://www.rfc-editor.org/rfc/rfc2119}{RFC 2119}.

\subsubsection{Mandatory Requirements}
\label{sec:Virtio Transport Options / Virtio Over Messages / Compliance / Mandatory}

\paragraph{General Transport Requirements}
\begin{itemize}
  \item An implementation MUST correctly process or generate all
    \emph{transport messages} defined by this specification that are necessary
    for device operation. At minimum, this includes:
    \begin{itemize}
      \item \msgref{GET_DEVICE_INFO}, \msgref{GET_DEVICE_FEATURES}, \msgref{SET_DRIVER_FEATURES}
      \item \msgref{GET_CONFIG}, \msgref{SET_CONFIG}
      \item \msgref{GET_VQUEUE}, \msgref{SET_VQUEUE}, \msgref{RESET_VQUEUE}
      \item \msgref{GET_DEVICE_STATUS}, \msgref{SET_DEVICE_STATUS}
    \end{itemize}
    Failure to support these messages renders a device or driver noncompliant.
  \item An implementation MUST adhere to the
    \textbf{transport revision} and \textbf{maximum message size} constraints
    indicated by each bus instance. For example, it MUST NOT exceed
    the \textbf{maximum message size} in any message.
\end{itemize}

\paragraph{Device-Side Requirements}
\begin{itemize}
  \item A device MUST provide accurate data in response to
    \msgref{GET_DEVICE_INFO}, including the correct \emph{device ID}, \emph{vendor ID},
    number of feature bits, and configuration size.
  \item A device MUST accept or reject driver-requested features via
    \msgref{SET_DRIVER_FEATURES} consistently with its capabilities and MUST
    return the final agreed-upon feature bits to the driver.
  \item A device MUST maintain a valid \emph{Configuration Generation
    Count} and MUST reject \msgref{SET_CONFIG} or similar operations if
    the generation count supplied by the driver does not match.
  \item A device MUST properly manage virtqueues configured via
    \msgref{SET_VQUEUE}, including storing and using the provided addresses for
    descriptor, driver, and device areas.
  \item A device MUST respect \msgref{SET_DEVICE_STATUS} changes: if the
    status is set to zero, the device MUST reset its internal state and
    discard any pending operations.
\end{itemize}

\paragraph{Driver-Side Requirements}
\begin{itemize}
  \item A driver MUST send valid requests that do not exceed
    the \textbf{maximum message size}, including correct offsets and block
    counts in \msgref{GET_DEVICE_FEATURES}, \msgref{SET_DRIVER_FEATURES}, \msgref{GET_CONFIG},
    and \msgref{SET_CONFIG}.
  \item A driver MUST handle a \msgref{SET_CONFIG} being rejected for a
    mismatched configuration generation count.
  \item A driver MUST initialize each device's virtqueues (where needed)
    via \msgref{SET_VQUEUE} before attempting normal I/O and SHOULD
    query the device's status or configuration if an unexpected
    \msgref{EVENT_CONFIG} or error arises.
\end{itemize}

\subsubsection{Optional Requirements}
\label{sec:Virtio Transport Options / Virtio Over Messages / Compliance / Optional}

\paragraph{Bus Messages for Enumeration and Hotplug}
\begin{itemize}
  \item Implementations MAY use \busref{GET_DEVICES}
    and \busref{EVENT_DEVICE} for discovering and managing devices in a
    message-driven manner. However, this is not mandatory if other enumeration
    methods (e.g., device tree, ACPI, hypervisor firmware) are used.
  \item If a bus chooses to implement these messages, it MUST do
    so in compliance with their defined formats and semantics (see
    \ref{sec:Virtio Transport Options / Virtio Over Messages / Bus Messages}).
\end{itemize}

\paragraph{Optional Bus-Level Messages}
\begin{itemize}
  \item \busref{PING} MAY be implemented for keepalive or health checks.
    If used, both sides MUST echo the 32-bit data field precisely.
\end{itemize}

\paragraph{Runtime Notifications}
\begin{itemize}
  \item A device or the driver side bus MUST send \msgref{EVENT_CONFIG}
    to inform the driver of configuration of device status changes.
  \item A device or the driver side bus MUST send \msgref{EVENT_USED}
    to inform the driver of (likely) buffer completions.
  \item A driver MUST send \msgref{EVENT_AVAIL} to notify the device that
    new buffers are available.
\end{itemize}

\subsubsection{Compliance for Different Environments}
\label{sec:Virtio Transport Options / Virtio Over Messages / Compliance / DifferentEnvs}

\paragraph{Bus Implementation}
A \emph{bus implementation} is compliant if:
\begin{itemize}
  \item It forwards \textbf{transport messages} to the appropriate device
    without altering or discarding valid requests.
  \item It enforces the \textbf{maximum message size} and \textbf{transport
    revision} advertised for its instance.
  \item If it implements bus messages (e.g., \busref{GET_DEVICES}, \busref{PING}),
    those MUST follow the formats in
    \ref{sec:Virtio Transport Options / Virtio Over Messages / Bus Messages}.
\end{itemize}

\paragraph{Driver Implementation}
A \emph{driver} is compliant if:
\begin{itemize}
  \item It correctly sends and interprets all required transport messages
    (\msgref{GET_DEVICE_INFO}, \msgref{SET_DRIVER_FEATURES}, \msgref{SET_CONFIG}, etc.).
  \item It respects the bus \textbf{transport revision}  and \textbf{maximum
    message size} limits for each bus instance.
  \item It properly handles device resets, ensuring that any
    subsequent re-initialization follows
    \ref{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization}.
\end{itemize}

\paragraph{Device Implementation}
A \emph{device} is compliant if:
\begin{itemize}
  \item It supports the core transport messages and enforces the
    \emph{Configuration Generation Count}.
  \item It implements feature negotiation correctly
  \item It respects \msgref{SET_DEVICE_STATUS} changes, resetting or shutting
    down if the status is cleared.
\end{itemize}

\subsubsection{Conformance Statements}
\label{sec:Virtio Transport Options / Virtio Over Messages / Compliance / Conformance}

An implementation MUST meet all "MUST" requirements stated in:
\begin{itemize}
  \item \ref{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts} (Basic Concepts)
  \item \ref{sec:Virtio Transport Options / Virtio Over Messages / Bus Operation} (Bus Operation)
  \item \ref{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization} (Device Initialization)
  \item \ref{sec:Virtio Transport Options / Virtio Over Messages / Device Operation} (Device Operation)
  \item This \ref{sec:Virtio Transport Options / Virtio Over Messages / Compliance} (Compliance) section
\end{itemize}
to claim compliance with the virtio-msg specification.

Implementations that do not follow these mandatory rules MUST NOT declare
themselves conformant. Features or messages labeled as "optional" (MAY)
do not invalidate compliance if omitted, provided all required behaviors are
still correctly implemented.
