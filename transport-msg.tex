\section{Virtio Over Messages}\label{sec:Virtio Transport Options / Virtio Over Messages}

\newcommand{\conceptref}[1]{\hyperref[sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts / #1]{#1}}
\newcommand{\msgref}[1]{\hyperref[sec:Virtio Transport Options / Virtio Over Messages / Transport Messages / VIRTIO_MSG_#1]{VIRTIO_MSG_#1}}
\newcommand{\busref}[1]{\hyperref[sec:Virtio Transport Options / Virtio Over Messages / Bus Messages / BUS_MSG_#1]{BUS_MSG_#1}}
\newcommand{\msgdef}[1]{\subsubsection{VIRTIO_MSG_#1}\label{sec:Virtio Transport Options / Virtio Over Messages / Transport Messages / VIRTIO_MSG_#1}}
\newcommand{\busdef}[1]{\subsubsection{BUS_MSG_#1}\label{sec:Virtio Transport Options / Virtio Over Messages / Bus Messages / BUS_MSG_#1}}

This section defines \textbf{virtio-msg}, a transport mechanism that encapsulates
virtio operations as discrete message exchanges rather than relying on PCI or
memory-mapped I/O regions. It separates bus-level functionality (e.g., device
enumeration, hotplug events) from device-specific operations (e.g., feature
negotiation, virtqueue setup), ensuring that a single, generic transport layer
can be reused across multiple bus implementations.

virtio-msg addresses several key objectives:

\begin{itemize}
  \item \textbf{Support multiple bus implementations:}
  Systems can rely on various communication methods such as hypercalls, local
  IPC, network channels, or device trees for enumerating devices. virtio-msg
  defines a common transport interface suitable for any of these mechanisms.

  \item \textbf{Reduce per-bus complexity:}
  Buses can implement a fully message-based workflow (including optional
  enumeration via \busref{GET_DEVICES} and hotplug via \busref{EVENT_DEVICE})
  or they can discover and manage devices through
  alternative means such as platform firmware data. In either case, they
  forward transport messages to and from each device.

  \item \textbf{Preserve virtio semantics:}
  The transport leverages standard virtio concepts (features, configuration
  space, virtqueues), so existing virtio drivers and device implementations can
  integrate smoothly once a device is discovered and registered.
\end{itemize}

\subsection{Basic Concepts}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts}

The virtio-msg transport relies on a set of foundational concepts to ensure
reusability across different bus implementations and flexibility in device
capabilities. This section defines those concepts and clarifies how they apply,
regardless of whether the bus leverages message-based enumeration or platform
data for device discovery.

\subsubsection{High-Level Architecture}

virtio-msg operates around two layers:

\begin{enumerate}
  \item \textbf{Bus Layer}: A \emph{bus instance} exposes zero or more virtio
        devices. It discovers available devices through mechanisms such as:
    \begin{itemize}
      \item Optional message-based queries (\busref{GET_DEVICES}),
      \item External data sources (e.g., device tree, ACPI tables, hypervisor
        firmware calls),
      \item Dynamic hotplug notifications (optionally via \busref{EVENT_DEVICE}).
    \end{itemize}
    Once a device is identified, regardless of discovery method, the bus
    uses \msgref{GET_DEVICE_INFO} to read its device ID and vendor ID, then
    \emph{registers} that device with the host OS so the usual virtio driver
    probe can occur.

  \item \textbf{Transport Layer}: After the bus knows about a device, the
        virtio-msg transport handles all device-specific operations:
    \begin{itemize}
      \item Retrieving and setting features (\msgref{GET_DEVICE_FEATURES},
        \msgref{SET_DRIVER_FEATURES}),
      \item Accessing the device configuration space (\msgref{GET_CONFIG},
        \msgref{SET_CONFIG}),
      \item Setting up virtqueues (\msgref{SET_VQUEUE}, \msgref{RESET_VQUEUE}),
      \item Managing status and runtime notifications (\msgref{SET_DEVICE_STATUS},
        \msgref{EVENT_USED}, etc.).
    \end{itemize}
    These transport messages remain the same across different bus instances,
    allowing a single virtio-msg driver component to function in multiple
    environments.
\end{enumerate}

\subsubsection{Relationship Between Bus and Transport}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts / Relationship between bus and transport}

This subsubsection explains the division of responsibilities: the bus layer is
the mandatory carrier that moves messages between driver and device endpoints
(e.g., over IPC, shared memory with signalling or hardware messaging), while
the virtio-msg transport defines the semantics of those messages.

virtio-msg groups messages into two categories:

\begin{description}
  \item[\textbf{Bus Messages}:]
    Intended for global bus operations such as enumerating device numbers
    (\busref{GET_DEVICES}), managing device hotplug events (\busref{EVENT_DEVICE})
    or assessing bus-wide health (\busref{PING}).
    These messages are \emph{optional} in environments where
    device discovery or state changes occur through other means (e.g., device
    tree). However, if a bus chooses to handle those tasks via messages,
    it implements the appropriate bus message definitions described in this
    section.

  \item[\textbf{Transport Messages}:]
    Used for device-specific operations, such as:
    \begin{itemize}
      \item Retrieving or setting features (\msgref{GET_DEVICE_FEATURES},
        \msgref{SET_DRIVER_FEATURES}),
      \item Accessing device configuration (\msgref{GET_CONFIG},
        \msgref{SET_CONFIG}),
      \item Managing virtqueues (\msgref{SET_VQUEUE}, \msgref{RESET_VQUEUE}),
      \item Handling device status and notifications (\msgref{SET_DEVICE_STATUS},
        \msgref{EVENT_USED}, etc.).
    \end{itemize}
\end{description}

This separation lets a bus remain minimal if it obtains device information from
firmware tables, while still supporting fully message-based enumeration and
hotplug when desired.

\busnormative{\paragraph}{Bus Message Implementation}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Relationship between bus and transport / Bus Messages}
\begin{itemize}
  \item A bus implementation that provides enumeration, hotplug, or bus
        health handling via bus messages SHOULD implement the corresponding Bus
        Message definitions described in this section.
\end{itemize}

\busnormative{\paragraph}{Transport Message Forwarding}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Relationship between bus and transport / Transport Message Forwarding}
\begin{itemize}
  \item A bus implementation MUST relay each transport message to the device
        number identified in the message header, regardless of how it
        discovered or enumerated that device.
  \item A bus implementation SHOULD treat transport messages as opaque apart
        from enforcing generic transport limits, such as the advertised maximum
        message size, and SHOULD NOT modify the transport payload.
\end{itemize}

\subsubsection{System Topology}

A virtio-msg system contains the following elements:

\begin{itemize}
  \item \textbf{Bus Instances and Devices}: Each bus instance advertises its
        capabilities (e.g., transport revision, maximum message size) and
        discovers devices via message-based queries or external data sources.
        Every discovered device has a unique \emph{device number}.
  \item \textbf{Driver}: Communicates with the bus to learn about
        available devices. Once a device is recognized, the driver uses the
        common transport messages to perform feature negotiation, configuration,
        and virtqueue setup.
  \item \textbf{Device}: Implement virtio device functionality and
        respond to the transport messages. The bus forwards these messages to
        the correct device instance based on device number.
\end{itemize}

\subsubsection{Transport Revisions and Maximum Message Size}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts / Revisions}

Each \textbf{virtio-msg bus instance} advertises the following to the transport
layer:
\begin{itemize}
  \item \textbf{Transport revision}: the protocol version supported by the bus
        instance (independent of the overall Virtio specification version).
  \item \textbf{Maximum message size}: the largest payload (in bytes) that can
        be carried per request or response, including the common header.
  \item \textbf{Transport feature bits}: revision-specific optional features
        implemented by the bus instance.
\end{itemize}

The mechanism for obtaining these parameters is implementation-defined and can
vary between bus instances. Common approaches include:
\begin{itemize}
  \item Reading firmware or device-tree data that describes each bus instance,
  \item Performing a message exchange during bus setup to retrieve the values,
  \item Relying on per-bus configuration structures or driver-specific defaults.
\end{itemize}

\busnormative{\paragraph}{Advertising Transport Parameters}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Revisions / Advertising Transport Parameters}
\begin{itemize}
  \item Each bus instance MUST make its transport revision, maximum message
        size, and transport feature bits available to the virtio-msg transport
        before any transport messages are exchanged for that device.
  \item A bus instance MUST apply the same limits to both driver-originated and
        device-originated transport messages; if the values change, the bus
        MUST inform the transport layer before accepting additional messages.
\end{itemize}

\drivernormative{\paragraph}{Respecting Bus Limits (Driver)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Revisions / Driver Limits}
\begin{itemize}
  \item A driver MUST NOT send a transport message whose total size exceeds the
        maximum message size advertised for the target bus instance.
  \item A driver MUST NOT rely on transport features or messages that require a
        higher transport revision than the bus instance reports.
\end{itemize}

\devicenormative{\paragraph}{Respecting Bus Limits (Device)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Revisions / Device Limits}
\begin{itemize}
  \item A device MUST ensure its responses and device-originated messages do
        not exceed the maximum message size advertised by the bus instance that
        relays them.
  \item A device MUST NOT require transport features or messages beyond the
        transport revision reported by the bus instance, and MUST respond with
        an error or ignore requests for unsupported features.
\end{itemize}

\paragraph{virtio-msg revisions}

The following table lists the currently defined virtio-msg revisions:

\begin{tabular}{ |l|l|l|l| }
\hline
\field{revision} & \field{maximum size} & \field{features}      & remarks \\
\hline \hline
1        & 44-65536    & <empty>   & Virtio Message Revision 1 \\
\hline
\end{tabular}

Note that a change in the virtio standard does not necessarily
correspond to a change in the virtio-msg revision.

The maximum message size is specified from the transport-layer point of view
and includes the 8-byte common header plus payload. Any extra encapsulation
imposed by the underlying bus (for example, a framing header) does not count
against this limit. Today the largest practical transport payload is 256 bytes:
messages such as GET_CONFIG and SET_CONFIG can carry up to 256 bytes of device
configuration in one transfer, and larger configuration regions can be accessed
through multiple exchanges without requiring a larger per-message limit.

\busnormative{\paragraph}{Message Size Bounds}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Revisions / Message Size}
\begin{itemize}
  \item A bus implementation MUST advertise a maximum message size of at least
        44 bytes.
  \item A bus implementation SHOULD NOT advertise a maximum message size that
        exceeds 264 bytes (256-byte payload plus the common header).
\end{itemize}

\paragraph{Versioning and Forward Compatibility}

A higher transport revision or additional transport feature bits extend the
protocol with new messages or capabilities. Implementations are expected to
remain interoperable across revisions: devices and drivers designed for a newer
revision still implement the mandatory messages and semantics defined in prior
revisions.

\drivernormative{\paragraph}{Revision Compatibility}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Versioning and Forward Compatibility / Driver}
\begin{itemize}
  \item A driver that negotiates transport revision $N$ MUST implement all
        mandatory driver behavior defined for revisions $1$ through $N$.
  \item If a driver receives a device-originated message or feature indication
        that requires an unsupported revision or transport feature, it MUST
        ignore the message (or treat the request as failed) and MUST NOT act on
        partially understood data.
\end{itemize}

\devicenormative{\paragraph}{Revision Compatibility}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Versioning and Forward Compatibility / Device}
\begin{itemize}
  \item A device that advertises transport revision $N$ MUST implement all
        mandatory device behavior defined for revisions $1$ through $N$.
  \item If a device receives a driver request that relies on an unsupported
        revision or transport feature, it MUST reject the request using the
        message-specific error mechanism (if any) or silently ignore it.
\end{itemize}

\busnormative{\paragraph}{Revision Compatibility}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Versioning and Forward Compatibility / Bus}
\begin{itemize}
  \item A bus instance that advertises transport revision $N$ MUST satisfy every
        bus requirement defined for revisions $1$ through $N$.
  \item If a bus instance cannot forward a message because it requires an
        unsupported revision or transport feature, it MUST surface a transport
        error or drop the message without forwarding it.
\end{itemize}

\subsubsection{Device Numbers and Enumeration}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts /
Device Numbers}

Each virtio-msg bus instance contains one or more \emph{devices}, identified
by a 16-bit \textbf{device number}. Buses discover these device numbers through
mechanisms such as:
\begin{itemize}
  \item \textbf{Message-Based Enumeration}: Using \busref{GET_DEVICES} to query
        which numbers exist (optional).
  \item \textbf{Platform Data}: A device tree, ACPI tables, or hypervisor calls
        might inform the bus of available device numbers and their properties.
\end{itemize}

Once a bus confirms that a device number is valid—regardless of the discovery
method—it normally issues \msgref{GET_DEVICE_INFO} to retrieve the device and
vendor IDs before registering the device with the host OS so the usual Virtio
driver binding process can begin.

\busnormative{\paragraph}{Device Number Assignment}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Device Numbers / Assignment}
\begin{itemize}
  \item A bus implementation MUST assign a unique device number to every
        device on a given bus instance and MUST NOT forward transport messages
        for a device number that has not been validated.
  \item A bus implementation SHOULD provide the driver with sufficient
        information—either via \busref{GET_DEVICES} or equivalent platform
        data—to discover each valid device number.
\end{itemize}

\subsubsection{Configuration Generation Count}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts / ConfigGen}

Each device maintains a \textbf{Configuration Generation Count} to prevent
inconsistent updates. This count is incremented at least once by the device for
every driver-visible change it makes to its configuration data. The current
count is exposed in \msgref{EVENT_CONFIG} and \msgref{GET_CONFIG} responses so
the driver can determine whether its view of the configuration is current. The
count does not necessarily start at zero and is not automatically reset when
the device resets.

\devicenormative{\paragraph}{Configuration Generation Count (Device)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / ConfigGen / Device}
\begin{itemize}
  \item A device MUST increment the generation count before it makes a change
        that is visible to the driver and MUST ensure that each
        \msgref{EVENT_CONFIG} carrying configuration data uses a unique
        generation count.
  \item If updated configuration data cannot fit in a single
        \msgref{EVENT_CONFIG}, the device SHOULD send an \msgref{EVENT_CONFIG}
        with zero data length to advertise the new generation count and MUST
        make the updated data available via \msgref{GET_CONFIG}.
  \item If a \msgref{SET_CONFIG} request includes a generation count that does
        not match the device's current count, the device MUST reject the
        request.
\end{itemize}

\drivernormative{\paragraph}{Configuration Generation Count (Driver)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / ConfigGen / Driver}
\begin{itemize}
  \item A driver MUST track the most recent generation count observed (via
        \msgref{EVENT_CONFIG} or \msgref{GET_CONFIG}) and include it in every
        \msgref{SET_CONFIG} request.
  \item If a \msgref{SET_CONFIG} request is rejected due to a mismatched
        generation count, the driver SHOULD issue \msgref{GET_CONFIG} to obtain
        the latest configuration data and generation count before retrying.
\end{itemize}

This mechanism ensures updates are not lost or overwritten due to stale
information.

\subsubsection{Feature Negotiation Blocks}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts / FeatureBlocks}

The virtio-msg transport organizes feature bits into 32-bit blocks accessed by
\msgref{GET_DEVICE_FEATURES} and \msgref{SET_DRIVER_FEATURES}. Each block
represents up to 32 feature bits:

\begin{itemize}
  \item \textbf{Block Index}: The starting block (e.g., block 0 for
        features 0--31, block 1 for features 32--63, etc.).
  \item \textbf{Number of Blocks}: How many blocks the driver wishes to retrieve
        or modify in a single message.
  \item \textbf{Feature Data}: The 32-bit values representing the supported (or
        driver-requested) feature bits in the selected blocks.
\end{itemize}

\devicenormative{\paragraph}{Feature Blocks (Device)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / FeatureBlocks / Device}
\begin{itemize}
  \item When \msgref{GET_DEVICE_FEATURES} covers blocks that extend beyond the
        features a device implements, the device MUST return zero for the
        feature data in those positions.
\end{itemize}

\subsubsection{Error Signaling}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts / ErrorSignaling}

Transport errors can arise from malformed messages, routing failures inside a
bus implementation, or device-side faults while processing a valid request.
Implementations should handle such faults locally where possible, but a bus may
surface an error to the virtio-msg transport if it cannot deliver a request or
obtain a response within its policy.

\busnormative{\paragraph}{Error Handling (Bus)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / ErrorSignaling / Bus}
\begin{itemize}
  \item A bus implementation MAY report a transport-visible failure (for
        example, after exhausting a bounded retry policy) when it cannot deliver
        a request or obtain a response.
  \item A bus implementation MUST treat malformed headers or unsupported
        \field{msg_id} values as invalid, MUST discard them without generating
        additional protocol traffic, and MAY log the condition for diagnostics.
  \item A bus implementation MUST NOT generate error responses to event
        (one-way) messages.
\end{itemize}

\devicenormative{\paragraph}{Error Handling (Device)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / ErrorSignaling / Device}
\begin{itemize}
  \item A device receiving a malformed or unsupported transport message MUST
        discard it without producing further protocol traffic.
  \item Recovery actions taken in response to an error (such as retries,
        selective resets, or device removal) MUST follow the normative reset and
        status semantics defined in
        \ref{sec:Virtio Transport Options / Virtio Over Messages / Device Operation}.
\end{itemize}

This specification does not define a dedicated error-reporting message; it only
permits implementations to surface failures when silent recovery is not
feasible.

\subsubsection{Endianness}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts / Endianness}

Unless otherwise stated, all numeric fields defined for virtio-msg messages use
little-endian encoding.

\drivernormative{\paragraph}{Endianness (Driver)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Endianness / Driver}
\begin{itemize}
  \item A driver MUST encode and decode the common header and payload fields
        defined by this transport using little-endian byte order.
\end{itemize}

\devicenormative{\paragraph}{Endianness (Device)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Endianness / Device}
\begin{itemize}
  \item A device MUST emit and consume the common header and payload fields
        defined by this transport using little-endian byte order.
\end{itemize}

\subsubsection{Common Message Format}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts / Common Message Format}

All virtio-msg exchanges, whether \emph{bus messages} or \emph{transport
messages}, begin with an 8-byte header followed by an optional payload. The
fields below describe the wire format for that header.

The header layout is:
\begin{lstlisting}
struct virtio_msg_header {
    u8       type;      /* request/response + bus/transport */
    u8       msg_id;    /* message id */
    le16     dev_num;   /* device number (0 for bus messages) */
    le16     token;     /* correlation identifier (0 for events) */
    le16     msg_size;  /* total size: header (8) + payload */
    u8       payload[];
};
\end{lstlisting}

Field semantics:
\begin{itemize}
  \item \field{type}:
    \begin{itemize}
  \item Bit[0]: 0=request, 1=response.
  \item Bit[1]: 0=transport message, 1=bus message.
  \item Bits[2..7]: reserved for future use.
    \end{itemize}
  \item \field{msg_id}: Message ID identifying the message definition. Ranges
    are defined in
    \ref{sec:Virtio Transport Options / Virtio Over Messages / Transport Messages}
    and
    \ref{sec:Virtio Transport Options / Virtio Over Messages / Bus Messages}.
  \item \field{dev_num}: For transport messages, the device number that should
    receive the message. Bus messages operate on device number 0.
  \item \field{token}: Requests use non-zero tokens so responses can be matched;
    event (one-way) messages use token 0 and do not expect a response.
  \item \field{msg_size}: Total size in bytes of the complete message (header
    plus payload).
  \item \field{payload}: Operation-specific data. If a bus introduces extra
    padding bytes, those bytes are not part of the payload semantics.
\end{itemize}

\drivernormative{\paragraph}{Common Header (Driver)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Common Message Format / Driver}
\begin{itemize}
  \item A driver MUST set bits 2..7 of \field{type} to zero and MUST treat them
        as reserved when parsing received headers.
  \item A driver MUST ensure \field{msg_size} reflects the total message length
        (header plus payload) and MUST NOT exceed the maximum message size
        advertised by the bus instance.
  \item A driver MUST set \field{token}=0 for event (one-way) messages and MUST
        assign a non-zero \field{token} for every request that expects a
        response.
  \item When sending a transport message, a driver MUST set \field{dev_num} to
        the intended device number.
  \item If a driver introduces padding bytes that become part of the transport
        payload, it MUST set those bytes to zero.
\end{itemize}

\devicenormative{\paragraph}{Common Header (Device)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Common Message Format / Device}
\begin{itemize}
  \item A device MUST set bits 2..7 of \field{type} to zero in transmitted
        messages and MUST ignore those bits on receive.
  \item A device MUST ensure \field{msg_size} reflects the total message length
        (header plus payload) and does not exceed the bus's advertised maximum.
  \item A device MUST set \field{token}=0 for event (one-way) messages it
        originates and MUST echo the \field{token} received in requests when
        producing responses.
  \item When sending a transport message, a device MUST set \field{dev_num} to
        its own device number.
  \item A device MUST ignore padding bytes that are documented as bus-specific
        and MUST zero any such bytes it introduces into the transport payload.
\end{itemize}

\busnormative{\paragraph}{Common Header (Bus)}{Virtio Transport Options / Virtio Over Messages / Basic Concepts / Common Message Format / Bus}
\begin{itemize}
  \item A bus implementation MUST deliver bus messages with \field{dev_num}=0
        and MUST NOT alter \field{dev_num} for transport messages beyond the
        routing needed to reach the addressed device.
  \item A bus implementation MUST set bits 2..7 of \field{type} to zero when
        generating bus messages and MUST ignore those bits when forwarding
        transport messages.
  \item If the bus adds framing or padding bytes around the common header or
        payload, it MUST set those bytes to zero before delivering the message
        to the opposite side and MUST present the same zero padding when the
        opposite side reads a message.
\end{itemize}

Reserved header bits and unspecified header values MUST be transmitted as zero
and ignored on receive to preserve forward compatibility.

\subsubsection{Message Correlation}
\label{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts / Correlation}

Messages are either requests or events. Requests require a response. Events are
one way and do not have a response. Most requests defined today originate at the
driver side but bus message requests such as \busref{PING} MAY originate at
either driver side or device side.

This section defines how responses are correlated to requests. An implementation
does not need to support sending multiple requests in parallel but these rules
allow for that possibility.

The token field in the message header is part of a tuple that is unique during
a request to response interval.
\begin{itemize}
  \item Message tuple: ( \field{dev_num}, \field{token} ).
\end{itemize}

Rules:
\begin{itemize}
  \item The request originator assigns a non-zero \field{token} for every
    request such that the tuple is unique for all inflight requests.
  \item Event (one-way) messages MUST set \field{token}=0
  \item A response MUST echo \field{token} and \field{dev_num}.
  \item Reception of unknown or already completed correlation tuples
    SHOULD result in discarding the response without further protocol
    action.
\end{itemize}

\subsection{Device Discovery}\label{sec:Virtio Transport Options / Virtio Over Messages / Device Discovery}

A virtio-msg implementation can learn about devices via bus-level enumeration
(e.g., \busref{GET_DEVICES}), platform data (e.g., device tree, ACPI), or
hypervisor/firmware interfaces. The following informative text describes
typical flows; the normative obligations follow.

Bus implementations MAY discover their devices in various ways:
\begin{itemize}
  \item By parsing platform data such as a device tree or ACPI tables,
  \item By receiving enumeration data from a hypervisor or firmware,
  \item By using \busref{GET_DEVICES} messages
    to query which device numbers are present on this bus instance.
\end{itemize}

This specification \emph{defines} \busref{GET_DEVICES} for implementations that
wish to carry out discovery entirely via messages, but it does \textbf{not}
mandate use of this approach. A bus implementation MAY skip
\busref{GET_DEVICES} altogether if it already knows which devices exist (e.g.,
via a device tree). In any case, once a bus has established the presence of a
device, it SHOULD call \msgref{GET_DEVICE_INFO} to retrieve the device ID
and vendor ID. The bus can then register the device with the host OS
so the appropriate virtio driver probe routine is invoked.

\subsection{Device Initialization}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization}

After a bus has identified a virtio-msg device (whether by message-based
enumeration or platform-specific discovery), the driver undertakes a series of
steps to configure and ready the device for normal operation. This section
details the recommended order of operations and the associated messages.

\subsubsection{Initialization Flow Overview}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization / Overview}

A typical device initialization flow includes:
\begin{enumerate}
  \item \textbf{Obtain Device Information:}  
    The driver queries the device's Device ID, vendor ID, feature block count,
    configuration size, and other static parameters of the device using
    \msgref{GET_DEVICE_INFO}.
  \item \textbf{Negotiate Features:}  
    The driver retrieves the device's feature bits (\msgref{GET_DEVICE_FEATURES}),
    determines which features it wants to enable, and writes the desired set
    with (\msgref{SET_DRIVER_FEATURES}).  It then attempts to set the
    FEATURES_OK bit in the device status (\msgref{SET_DEVICE_STATUS}) and
    verifies that it is set in the return device status.
  \item \textbf{Initialize Configuration Space:}  
    The driver MAY read (\msgref{GET_CONFIG}) or modify (\msgref{SET_CONFIG})
    configuration data, using the device's \emph{Configuration Generation Count}
    to prevent race conditions.
  \item \textbf{Set Up Virtqueues:}  
    The driver configures each virtqueue (e.g., number of descriptors, base
    addresses) via \msgref{SET_VQUEUE} and verifies each queue's readiness
    (\msgref{GET_VQUEUE}).
  \item \textbf{Set Device Status:}  
    The driver updates the device's status with \msgref{SET_DEVICE_STATUS} to
    indicate initialization progress (e.g., from "reset" to "acknowledge,"
    "driver," or "driver OK," following Virtio conventions).
\end{enumerate}

This sequence MAY vary slightly depending on the device's requirements, but it
serves as a common baseline for virtio-msg transport implementations.

\subsubsection{Device Information}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization / Device Information}

Once the bus or driver knows a device number is present, it SHOULD send a
\msgref{GET_DEVICE_INFO} to retrieve:

\begin{itemize}
  \item \textbf{Device ID}: Identifies the type of Virtio device (e.g., network,
    block, console).
  \item \textbf{Vendor ID}: Identifies the vendor or implementation source.
  \item \textbf{Number of Feature Bits}: Indicates how many bits (organized in
    32-bit blocks) the device uses for feature negotiation.
  \item \textbf{Configuration Size}: The total size (in bytes) of the device's
    configuration space.
  \item \textbf{Number of virtqueues}: The maximum number of virtqueues the
    device supports.
  \item \textbf{Number of SHM segments}: The number of device owned
    shared memory segments this device has.
  \item \textbf{Admin virtqueue starting index}: The virtqueue index for the
    first admin virtqueue supported by the device.
  \item \textbf{Admin virtqueue count}: The number of admin virtqueues
    supported by the device.
\end{itemize}

Armed with these details, the driver knows how many feature blocks to query,
what portion of the configuration space is valid, and which OS-level virtio
driver might bind to this device based on the Device ID.

It also knows of any device owned shared memory segments and any admin
virtqueues supported by the device.

\subsubsection{Feature Negotiation}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization / Device Features}

The driver reads the device's available features in \textbf{blocks of 32 bits}
using \msgref{GET_DEVICE_FEATURES}, supplying a \emph{block index} and
\emph{number of blocks} to retrieve. The device responds with the feature bits
in that range, filling any out-of-range blocks with zero.

The driver then determines which features it can or wants to enable. Enabling a
feature requires the driver to set the corresponding bit(s) and send
them back to the device with \msgref{SET_DRIVER_FEATURES}. Once the driver has
set all desired features it tries to set the FEATURES_OK bit in the device status
via the \msgref{SET_DEVICE_STATUS} message.  The device MAY accept or reject the
selected features by returning the new device status with the FEATURES_OK bit
set (accepted) or cleared (rejected).

If the driver requests blocks beyond the number of feature bits the device
exposes, the device MUST respond with all zeros for the unsupported
features.

\subsubsection{Device Configuration}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization / Device Configuration}

\paragraph{Reading Configuration}

The driver can read portions of the device's configuration space using
\msgref{GET_CONFIG}. It supplies:
\begin{itemize}
  \item \textbf{Offset}: The byte offset from the start of the configuration
    space,
  \item \textbf{Number of bytes}: How many bytes to retrieve.
\end{itemize}
The device returns the requested data along with the current \emph{Configuration
Generation Count}, which changes each time the device updates its configuration
internally.

\paragraph{Writing Configuration}

To write a portion of the configuration space, the driver uses
\msgref{SET_CONFIG}, providing:
\begin{itemize}
  \item \textbf{Offset} and \textbf{Number of bytes},
  \item \textbf{Configuration generation count} as read earlier,
  \item The \textbf{new configuration data} to be written.
\end{itemize}

If the generation count does not match the device's current value, the device
MUST reject the update as defined in the \msgref{SET_CONFIG} response.
The driver SHOULD then read the updated configuration space and
reattempt if necessary.

\subsubsection{Virtqueue Configuration}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization / Virtqueue Configuration}

Virtqueues are configured via a set of transport messages:

\begin{itemize}
  \item \msgref{GET_VQUEUE} obtains information about a specific virtqueue,
    including its maximum size (e.g., number of descriptors) and current
    configuration if already set.
  \item \msgref{SET_VQUEUE} sets or updates the virtqueue parameters (e.g.,
    queue size, descriptor area addresses, driver address, device address).
  \item \msgref{RESET_VQUEUE} disables and resets the virtqueue, freeing its
    resources on the device side.  The use of this message is dependent on the
    VIRTIO_F_RING_RESET feature being negotiated.
\end{itemize}

A typical approach is:
\begin{enumerate}
  \item \textbf{GET\_VQUEUE}: Determine maximum size and confirm that the queue
        is inactive or empty.
  \item \textbf{SET\_VQUEUE}: Specify the number of descriptors (not exceeding
        the maximum) and the addresses for the descriptor table, driver area,
        and device area.  
\end{enumerate}

The driver repeats these steps for each queue the device supports.

\subsubsection{Status Information}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization / Status Information}

During initialization, the driver MAY query the device's status via
\msgref{GET_DEVICE_STATUS} to check for errors or to see if the device is ready
for feature negotiation or configuration changes. To advance or reset the
device's state, the driver sends \msgref{SET_DEVICE_STATUS} with the desired
status bits (e.g., "ACKNOWLEDGE," "DRIVER," "DRIVER OK"). Setting the device's
status to 0 triggers a device reset, invalidating configuration and
virtqueues.

\subsubsection{Finalizing Initialization}

Once all virtqueues are configured and any required features have been enabled,
the driver typically sets the final status bits (e.g., "DRIVER OK") via
\msgref{SET_DEVICE_STATUS}. At this point, the device is considered fully
initialized, and normal I/O operations can begin using virtio queues.

\subsection{Device Operation}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Operation}

Once a virtio-msg device is fully initialized (see
\ref{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization}),
the driver and device exchange messages to perform I/O and respond to
configuration changes. This section details the primary messaging paths for
\emph{driver notifications}, \emph{device notifications}, and the handling of
runtime resets or shutdown sequences.

\subsubsection{Driver Notifications}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Operation / Driver Notifications}

After setting up one or more virtqueues, the driver MUST send notifications
to signal that new buffers are available for processing. The virtio-msg transport
defines the message, \msgref{EVENT_AVAIL}, that the driver will use to
notify the device of pending buffers.

The driver side bus MAY convert them to some form of
out-of-band (OoB) notification.  If not using OoB notifications, the driver
side bus SHOULD send the messages via the normal message channel.
As a final option, the bus MAY discard the messages but only if it knows
that the device will poll the virtqueues directly.

\paragraph{EVENT\_AVAIL Usage}
\begin{itemize}
  \item \textbf{Virtqueue Index}: Identifies which queue has new buffers.
  \item \textbf{Next Offset and Wrap}: If the VIRTIO_F_NOTIFICATION_DATA feature
        has been negotiated, the driver MUST sets these fields to
        indicate the next descriptor offset and wrap state
        so the device can jump directly to the updated buffers.
        If this features has not been negotiated these fields MUST be 0.
  \item \textbf{Response}: The \msgref{EVENT_AVAIL} message does not have a
        direct response, but the device will subsequently process available
        buffers and eventually notify the driver when they are used.
\end{itemize}

\subsubsection{Device Notifications}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Operation / Device Notifications}

During normal operation, the driver side bus MUST send notifications to
the driver about configuration changes, device status changes, or the
completion of buffers in virtqueues using the messages described below.
These notifications MAY be the result of:

\begin{itemize}
    \item The same messages received in-band on the message channel from the
        device side bus.
    \item Manufactured by the driver side bus based on reception of an
        out-of-band (OoB) notification from the device side.  Example OoB
        notifications include things like specific MSIX or other IRQ signals.
    \item Manufactured by the device side bus periodically (polling).
        This option SHOULD be reserved only for situation where nothing else
        will work.
  \end{itemize}

\paragraph{EVENT\_CONFIG}
\begin{itemize}
  \item Sent by the device when a configuration field or device status changes
    at runtime.
  \item Includes the new \emph{Configuration Generation Count}, current device
    status, and optionally the updated portion of the configuration data.
  \item If the data is not included, the driver SHOULD issue
    \msgref{GET_CONFIG} to discover the updated configuration.
\end{itemize}

\paragraph{EVENT\_USED}
\begin{itemize}
  \item Signifies that one or more buffers in a specific virtqueue have been
    processed or consumed by the device and the buffer has been added to the
    used ring of the virtqueue.
  \item The driver uses normal virtio methods (e.g., reading the "used" ring) to
    identify which buffers are complete.
  \item If a device does not support sending \msgref{EVENT_USED}, the driver
     MAY rely on standard virtqueue polling mechanisms to detect
     completion.
\end{itemize}

These messages enable asynchronous updates from the device.

\subsubsection{Configuration Changes During Operation}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Operation / ConfigUpdates}

The driver MAY issue new \msgref{SET_CONFIG}
messages after initialization if device configuration needs to be
changed at runtime. The device MAY also make configuration changes at
runtime and MUST signal those changes with \msgref{EVENT_CONFIG}
messages.

\subsubsection{Virtqueue Changes During Operation}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Operation / VQueueUpdates}

The driver MAY issue new \msgref{SET_VQUEUE} for virtqueues that have not
yet be setup.  If the VIRTIO_F_RING_RESET feature has been negotiated,
individual virtqueues can be reset and then optionally re-configured.

\subsubsection{Device Reset and Shutdown}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Operation / Reset}

The driver MAY reset or shut down a device at any time by writing a status
of 0 via \msgref{SET_DEVICE_STATUS}. This forces the device to discard its state
and any pending operations on virtqueues. Once a device is reset, the driver
MAY reinitialize the device (see
\ref{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization})
if it wishes to use the device again.

\paragraph{Device Side Initiated Reset}
In some circumstances, the device MAY also trigger a reset if it
encounters an unrecoverable error. This can be signaled to the driver by sending
an \msgref{EVENT_CONFIG} with a \emph{device status} with the DEVICE_NEEDS_RESET
bit set.  The driver SHOULD reset the device by writing a status of 0
via the \msgref{SET_DEVICE_STATUS} message. The driver MAY reinitialize
the device if it wishes to use the device again.

\subsubsection{Hotplug and Removal}
\label{sec:Virtio Transport Options / Virtio Over Messages / Device Operation / Hotplug and Removal}

If the bus supports dynamic addition or removal of devices at runtime, it
MAY announce these events using messages:
\begin{itemize}
  \item \busref{EVENT_DEVICE} with state DEVICE_BUS_STATE_READY for a newly
    available device,
  \item \busref{EVENT_DEVICE} with state DEVICE_BUS_STATE_REMOVED for a device
    that is no longer accessible.
\end{itemize}

Alternatively, the bus MAY rely on external signals (e.g., an event from
the platform or hypervisor) and inform the OS of hotplug changes out-of-band.
This specification \emph{defines} \busref{EVENT_DEVICE}
for implementations that prefer a fully message-based
approach but does not require their use. In any scenario, once notified that a
device has appeared, the bus SHOULD query the device (e.g., via
\msgref{GET_DEVICE_INFO}) and register it with the OS. If a device is
removed, the bus SHOULD prompt the OS to unbind and release resources.

\subsection{Transport Messages}\label{sec:Virtio Transport Options / Virtio Over Messages / Transport Messages}

Transport messages are used to configure and operate individual virtio devices.
Unlike bus messages (which handle device enumeration, hotplug, or global resets),
transport messages MUST be implemented by any virtio-msg device and
driver pair to enable standard virtio functionality (feature negotiation,
configuration, virtqueues, etc.). The subsections below describe each message
and clarify its required fields, typical usage patterns, and possible responses.

\subsubsection{Overview}
\label{sec:Virtio Transport Options / Virtio Over Messages / Transport Messages / Overview}

A driver typically sends these messages to a known device number,
and the virtio-msg device responds or notifies as appropriate. The
bus \emph{forwards} these messages but does not interpret or modify them beyond
basic checks (e.g., ensuring the size does not exceed the maximum size
supported, verifying the target device number exists).

Most transport messages adopt a \emph{request/response} pattern, but some are
unidirectional (e.g., asynchronous notifications).

\paragraph{Messages IDs and issuers}

\begin{tabular}{|l|l|l|}
\hline
Name & ID & Sender \\
\hline
\hline
Reserved                   & 0x0 & \\
\hline
Reserved                   & 0x1 & \\
\hline
\msgref{GET_DEVICE_INFO}   & 0x2  & Driver \\
\hline
\msgref{GET_DEVICE_FEATURES} & 0x3  & Driver \\
\hline
\msgref{SET_DRIVER_FEATURES} & 0x4  & Driver \\
\hline
\msgref{GET_CONFIG}        & 0x5  & Driver \\
\hline
\msgref{SET_CONFIG}        & 0x6  & Driver \\
\hline
\msgref{GET_DEVICE_STATUS} & 0x7  & Driver \\
\hline
\msgref{SET_DEVICE_STATUS} & 0x8  & Driver \\
\hline
\msgref{GET_VQUEUE}        & 0x9  & Driver \\
\hline
\msgref{SET_VQUEUE}        & 0xA  & Driver \\
\hline
\msgref{RESET_VQUEUE}      & 0xB  & Driver \\
\hline
\msgref{GET_SHM}           & 0xC  & Driver \\
\hline
\msgref{EVENT_CONFIG}      & 0x40 & Device \\
\hline
\msgref{EVENT_AVAIL}       & 0x41 & Driver \\
\hline
\msgref{EVENT_USED}        & 0x42 & Device \\
\hline
\end{tabular}

Transport message IDs 0x00 to 0x3F are used for messages that require a response
and IDs 0x40 to 0x7F are used for event messages. Transport message IDs 0x80
and above are reserved by this specification.

\paragraph{Mandatory Transport Messages}
For a virtio-msg device to be fully operational, the following messages
MUST be supported:
\begin{itemize}
  \item \msgref{GET_DEVICE_INFO}
  \item \msgref{GET_DEVICE_FEATURES} and \msgref{SET_DRIVER_FEATURES}
  \item \msgref{GET_CONFIG} and \msgref{SET_CONFIG}
  \item \msgref{GET_DEVICE_STATUS} and \msgref{SET_DEVICE_STATUS}
  \item \msgref{GET_VQUEUE}, \msgref{SET_VQUEUE}, and \msgref{RESET_VQUEUE}
\end{itemize}

The functionality of the following messages MUST be provided by
in-band messages, out-of-band event notification, or bus implementation based
polling:
\begin{itemize}
  \item \msgref{EVENT_AVAIL}
  \item \msgref{EVENT_USED}
  \item \msgref{EVENT_CONFIG}
\end{itemize}

\msgdef{GET_DEVICE_INFO}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 0 & None \\
\hline
Answer & 0 & 4 & Device ID \\
& 4 & 4 & Vendor ID \\
& 8 & 4 & Number of feature bits \\
& 12 & 4 & Configuration size in bytes \\
& 16 & 4 & Maximum number of virtqueues \\
& 20 & 2 & Admin virtqueue start index \\
& 22 & 2 & Admin virtqueue count \\
\hline
\end{tabular}

The number of feature bits MUST be a multiple of 32.

This is the only message allowed for an inactive device. If this message queries
an inactive device all fields in the response SHOULD be 0.

\msgdef{GET_DEVICE_FEATURES}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Feature block index \\
& 4 & 4 & Number of feature blocks \\
\hline
Answer & 0 & 4 & Feature block index \\
& 4 & 4 & Number of feature blocks \\
& 8 & ... & Feature data \\
\hline
\end{tabular}

A feature block is a group of 32 bits.  The feature data MUST be a
multiple of 4 bytes in length.

\msgdef{SET_DRIVER_FEATURES}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Feature block index \\
& 4 & 4 & Number of feature blocks \\
& 8 & ... & Feature data \\
\hline
Answer & 0 & 0 & no extra data \\
\hline
\end{tabular}

A feature block is a group of 32 bits.  The feature data MUST be a
multiple of 4 bytes in length.

Note: As defined in \ref{sec:Basic Facilities of a Virtio Device / Feature Bits},
if the device is not OK with the features set, it MUST not allow
the FEATURES_OK bit in the device status to be set.

\msgdef{GET_CONFIG}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Configuration offset in bytes \\
& 4 & 4 & Number of bytes \\
\hline
Answer & 0 & 4 & Configuration generation count \\
& 4 & 4 & Configuration offset in bytes \\  \\
& 8 & 4 & Number of bytes \\
& 12 & ... & Configuration data \\
\hline
\end{tabular}

\msgdef{SET_CONFIG}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Configuration generation count \\
& 4 & 4 & Configuration offset in bytes \\
& 8 & 4 & Number of bytes \\
& 12 & ... & Configuration data \\
\hline
Answer & 0 & 4 & New Configuration generation count \\
& 4 & 4 & Configuration offset in bytes \\
& 8 & 4 &  Number of bytes, or 0 if rejected \\
& 12 & ... & Configuration data \\
\hline
\end{tabular}

See \ref{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization / Device Configuration}
for details about rejection and for new data not equal to written data.

\msgdef{GET_DEVICE_STATUS}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 0 & None \\
\hline
Answer & 0 & 4 & Device status \\
\hline
\end{tabular}

\msgdef{SET_DEVICE_STATUS}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Device status \\
\hline
Answer & 0 & 4 & New device status \\
\hline
\end{tabular}

The resulting device status is returned and MAY not match the status set.  The
device MAY set the DEVICE_NEEDS_RESET bit if it has an issue.  The device MAY
refuse to set the FEATURES_OK bit if it cannot operate with the features set
by the driver.

\msgdef{GET_VQUEUE}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Virtqueue index \\
\hline
Answer & 0 & 4 & Virtqueue index \\
& 4 & 4 & Maximum virtqueue size \\
& 8 & 4 & Current virtqueue size \\
& 12 & 4 & Reserved (Must Be Zero - MBZ) \\
& 16 & 8 & Descriptor address \\
& 24 & 8 & Driver address \\
& 32 & 8 & Device address \\
\hline
\end{tabular}

If the maximum virtqueue size is zero, the virtqueue is not valid and
MUST not be used.

\msgdef{SET_VQUEUE}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Virtqueue index \\
& 4 & 4 & Reserved (Must Be Zero - MBZ) \\
& 8 & 4 & Current virtqueue size \\
& 12 & 4 & Reserved (Must Be Zero - MBZ) \\
& 16 & 8 & Descriptor address \\
& 24 & 8 & Driver address \\
& 32 & 8 & Device address \\
\hline
Answer & 0 & 0 & no extra data \\
\hline
\end{tabular}

\msgdef{RESET_VQUEUE}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

The driver SHOULD NOT send this message unless the VIRTIO_F_RING_RESET
feature has been negotiated.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Virtqueue index \\
\hline
Answer & 0 & 0 & no extra data \\
\hline
\end{tabular}

\msgdef{GET_SHM}

This message is sent by the virtio-msg transport driver and requires a
response from the device.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Shared memory region index \\
\hline
Answer & 0 & 4 & Shared memory region index \\
& 4 & 4 & Shared memory region length \\
& 8 & 4 & Shared memory region address \\
\hline
\end{tabular}

If the returned shared memory region length is zero, the memory region does not
exist.

Note: these shared memory regions are device owned and supported on other virtio
transports since virtio v1.3. These shared memory regions are separate and
distinct from any shared memory regions defined by the bus implementation.

\msgdef{EVENT_CONFIG}

This message is sent by the virtio-msg device and there is no response.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Device status \\
& 4 & 4 & Configuration generation count \\
& 8 & 4 & Configuration offset \\
& 12 & 4 & Number of bytes (MAY be zero) \\
& 16 & ... & Configuration data \\
\hline
\end{tabular}

The number of bytes field MAY be zero. If so the configuration data field
will also be of zero length. This is the normal case when the configuration
generation count has not been changed.

If the number of bytes field is zero and the configuration generation count is
changed, then the driver is responsible for discovering any changed
configuration data via \msgref{GET_CONFIG} messages.

\msgdef{EVENT_AVAIL}

This message is sent by the virtio-msg driver and there is no response.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Virtqueue index \\
& 4 & 4 & Next offset and Next wrap \\
\hline
\end{tabular}

The \textbf{Next wrap} field is the MSB of the 32 bit value. The
\textbf{Next offset} field is the other 31 bits. These fields SHOULD be 0 if
the VIRTIO_F_NOTIFICATION_DATA feature has not been negotiated. If the bus
implementation is using out-of-band notifications, it SHOULD prevent this
feature from being negotiated.

\msgdef{EVENT_USED}

This message is sent by the virtio-msg device and there is no response.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 4 & Virtqueue index \\
\hline
\end{tabular}

\subsection{Bus Messages}\label{sec:Virtio Transport Options / Virtio Over Messages / Bus Messages}

The bus messages defined in this specification facilitate device discovery,
hotplug management, and liveness checks at the bus level.
They are intended for bus implementations that wish to perform these operations
\emph{via virtio-msg} rather than relying exclusively on external means (e.g.,
firmware tables, device trees). Each bus instance MAY use a subset of or
all these messages according to its design.

\subsubsection{Overview}
\label{sec:Virtio Transport Options / Virtio Over Messages / Bus Messages / Overview}

A bus implementation \textbf{is not required} to use these
messages if it already provides equivalent functionality through some
platform-specific mechanism. However, if a bus chooses to handle enumeration,
hotplug, etc. via virtio-msg, it SHOULD implement the corresponding
message definitions below.

\paragraph{Messages IDs and issuers}

\begin{tabular}{|l|l|l|}
\hline
Name & ID & Sender \\
\hline
\hline
Reserved                    & 0x0  &        \\
\hline
Reserved                    & 0x1  &        \\
\hline
\busref{GET_DEVICES}        & 0x2  & Driver \\
\hline
\busref{PING}               & 0x3  & Any    \\
\hline
\busref{EVENT_DEVICE}       & 0x40 & Device \\
\hline
\end{tabular}

Bus message IDs below 0x80 are reserved for standardized (but optional) bus
messages.  A few are used here and more are expected in the future. Bus message
IDs below 0x40 are used for request/response messages and 0x40 and above for
event messages.

Bus message IDs 0x80 and above are bus implementation specific. Bus
implementations MAY specify the policy that IDs below 0xC0 be used
for request/response messages and IDs 0xC0 and above are used for event messages.

\paragraph{Bus Specific Messages}
\label{sec:Virtio Transport Options / Virtio Over Messages / Bus Operation / Bus Specific Messages}

A range of message IDs are reserved for use by the specific bus
implementation. These messages can be used for any implementation specific
usage. Example usage could include:

\begin{itemize}
  \item Configuration of out-of-band notification methods
  \item Setup shared memory regions to be used for buffers or virtqueues
  \item Declare bus specific error conditions
  \item Provide extra debug or logging information
\end{itemize}

\busdef{GET_DEVICES}

The driver-side bus uses this request to enumerate device numbers on the
device-side bus. The response describes a “window” of device numbers and signals
which entries are present.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 2 & offset: first device number in the window \\
        & 2 & 2 & count: number of consecutive device numbers covered \\
\hline
Answer  & 0 & 2 & offset (echoed) \\
        & 2 & 2 & count actually returned \\
        & 4 & 2 & next\_offset: 0 or the start of the recommended next window \\
        & 6 & count/8 & bitmap: bit $n$ ($0 \le n <$ count) describes device number $(offset + n)$ (0=absent, 1=present) \\
\hline
\end{tabular}

\textbf{offset} and \textbf{count} MUST be multiples of 8; the bitmap length is
\textbf{count/8} and is packed LSB-first (device number \textbf{offset} is the
LSB of the first byte).
\textbf{next_offset} is either 0 (no further windows) or an aligned value
$\ge offset + count$ that the responder suggests querying next.

The \textbf{(offset, count)} tuple defines a window of \textbf{count}
consecutive device numbers beginning at \textbf{offset}. The number of present
devices equals the number of 1-bits in the bitmap. Responders SHOULD return the
requested \textbf{count} unless constrained (e.g., by maximum message size);
otherwise they MAY return a smaller value, in which case the bitmap covers the
reduced window.

Example: a request with \textbf{offset}=0, \textbf{count}=16 might produce
\textbf{bitmap}=0b00100101 00000000 and \textbf{next_offset}=16. That indicates
devices 0, 2, and 5 are present within the 0–15 window and suggests continuing
at device number 16.

\paragraph{Intended usage}
Drivers MAY use this message to enumerate device numbers. Treat each window as
a snapshot, advance using \textbf{next_offset}, and confirm candidates via
\msgref{GET_DEVICE_INFO} before issuing other transport messages.

\busdef{EVENT_DEVICE}

This message is sent by the virtio-msg device side bus and there is no response.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
\hline \hline
Request & 0 & 2 & Device Number \\
        & 2 & 2 & Device Bus State \\
\hline
\end{tabular}

\begin{tabular}{|l|l|l|}
\hline
Device Bus State & Value & Meaning \\
\hline
\hline
DEVICE_BUS_STATE_READY      & 0x1  & Device is present and ready \\
\hline
DEVICE_BUS_STATE_REMOVED    & 0x2  & Device is no longer present \\
\hline
reserved          & 0x3 to 0x7FFF & Reserved for standard use \\
\hline
any               & 0x8000 to 0xFFFF & MAY be used by bus implementations \\
\hline
\end{tabular}

This event is sent when the bus level state of the device has changed.
It can indicate when a device is added or removed. It MAY also be used by
bus implementations to indicate other states.

\paragraph{Intended usage}
This message advertises device presence or removal. Upon READY, drivers SHOULD
probe the device via \msgref{GET_DEVICE_INFO} and proceed with initialization
if successful. Upon REMOVED, drivers MUST stop queueing new requests,
quiesce/reset as applicable, and release resources. Drivers SHOULD tolerate
duplicates and out-of-order events, and MAY use bus-level monitoring (see
\busref{PING}) to refine policy.

\busdef{PING}

This message is sent by the virtio-msg driver side bus or device side bus and
requires a response.

\begin{tabular}{|l|l|l|l|}
\hline
Type & Offset & Size (bytes) & Content \\
 \hline \hline
Request & 0 & 4 & Data \\
\hline
Answer & 0 & 4 & Request Data \\
\hline
\end{tabular}

\paragraph{Intended usage}
Drivers MAY treat \busref{PING} as an optional keepalive or monitoring
mechanism. Timeouts or missing replies SHOULD trigger validation of device
state via \msgref{GET_DEVICE_STATUS} and recovery as appropriate.

\subsection{Compliance}
\label{sec:Virtio Transport Options / Virtio Over Messages / Compliance}

This section details the requirements that an implementation MUST meet to
be considered compliant with the virtio-msg transport. It distinguishes between
\emph{mandatory} behaviors that all implementations MUST support and
\emph{optional} behaviors that are permissible but not required.

\subsubsection{Normative References}
\label{sec:Virtio Transport Options / Virtio Over Messages / Compliance / NormativeRefs}
The terms MUST, MUST NOT, SHOULD, SHOULD NOT,
and MAY in this document are to be interpreted as specified by
\href{https://www.rfc-editor.org/rfc/rfc2119}{RFC 2119}.

\subsubsection{Mandatory Requirements}
\label{sec:Virtio Transport Options / Virtio Over Messages / Compliance / Mandatory}

\paragraph{General Transport Requirements}
\begin{itemize}
  \item An implementation MUST correctly process or generate all
    \emph{transport messages} defined by this specification that are necessary
    for device operation. At minimum, this includes:
    \begin{itemize}
      \item \msgref{GET_DEVICE_INFO}, \msgref{GET_DEVICE_FEATURES}, \msgref{SET_DRIVER_FEATURES}
      \item \msgref{GET_CONFIG}, \msgref{SET_CONFIG}
      \item \msgref{GET_VQUEUE}, \msgref{SET_VQUEUE}, \msgref{RESET_VQUEUE}
      \item \msgref{GET_DEVICE_STATUS}, \msgref{SET_DEVICE_STATUS}
    \end{itemize}
    Failure to support these messages renders a device or driver noncompliant.
  \item An implementation MUST adhere to the
    \textbf{transport revision} and \textbf{maximum message size} constraints
    indicated by each bus instance. For example, it MUST NOT exceed
    the \textbf{maximum message size} in any message.
\end{itemize}

\paragraph{Device-Side Requirements}
\begin{itemize}
  \item A device MUST provide accurate data in response to
    \msgref{GET_DEVICE_INFO}, including the correct \emph{device ID}, \emph{vendor ID},
    number of feature bits, and configuration size.
  \item A device MUST accept or reject driver-requested features via
    \msgref{SET_DRIVER_FEATURES} consistently with its capabilities and MUST
    return the final agreed-upon feature bits to the driver.
  \item A device MUST maintain a valid \emph{Configuration Generation
    Count} and MUST reject \msgref{SET_CONFIG} or similar operations if
    the generation count supplied by the driver does not match.
  \item A device MUST properly manage virtqueues configured via
    \msgref{SET_VQUEUE}, including storing and using the provided addresses for
    descriptor, driver, and device areas.
  \item A device MUST respect \msgref{SET_DEVICE_STATUS} changes: if the
    status is set to zero, the device MUST reset its internal state and
    discard any pending operations.
\end{itemize}

\paragraph{Driver-Side Requirements}
\begin{itemize}
  \item A driver MUST send valid requests that do not exceed
    the \textbf{maximum message size}, including correct offsets and block
    counts in \msgref{GET_DEVICE_FEATURES}, \msgref{SET_DRIVER_FEATURES}, \msgref{GET_CONFIG},
    and \msgref{SET_CONFIG}.
  \item A driver MUST handle a \msgref{SET_CONFIG} being rejected for a
    mismatched configuration generation count.
  \item A driver MUST initialize each device's virtqueues (where needed)
    via \msgref{SET_VQUEUE} before attempting normal I/O and SHOULD
    query the device's status or configuration if an unexpected
    \msgref{EVENT_CONFIG} or error arises.
\end{itemize}

\subsubsection{Optional Requirements}
\label{sec:Virtio Transport Options / Virtio Over Messages / Compliance / Optional}

\paragraph{Bus Messages for Enumeration and Hotplug}
\begin{itemize}
  \item Implementations MAY use \busref{GET_DEVICES}
    and \busref{EVENT_DEVICE} for discovering and managing devices in a
    message-driven manner. However, this is not mandatory if other enumeration
    methods (e.g., device tree, ACPI, hypervisor firmware) are used.
  \item If a bus chooses to implement these messages, it MUST do
    so in compliance with their defined formats and semantics (see
    \ref{sec:Virtio Transport Options / Virtio Over Messages / Bus Messages}).
\end{itemize}

\paragraph{Optional Bus-Level Messages}
\begin{itemize}
  \item \busref{PING} MAY be implemented for keepalive or health checks.
    If used, both sides MUST echo the 32-bit data field precisely.
\end{itemize}

\paragraph{Runtime Notifications}
\begin{itemize}
  \item A device or the driver side bus MUST send \msgref{EVENT_CONFIG}
    to inform the driver of configuration of device status changes.
  \item A device or the driver side bus MUST send \msgref{EVENT_USED}
    to inform the driver of (likely) buffer completions.
  \item A driver MUST send \msgref{EVENT_AVAIL} to notify the device that
    new buffers are available.
\end{itemize}

\subsubsection{Compliance for Different Environments}
\label{sec:Virtio Transport Options / Virtio Over Messages / Compliance / DifferentEnvs}

\paragraph{Bus Implementation}
A \emph{bus implementation} is compliant if:
\begin{itemize}
  \item It forwards \textbf{transport messages} to the appropriate device
    without altering or discarding valid requests.
  \item It enforces the \textbf{maximum message size} and \textbf{transport
    revision} advertised for its instance.
  \item If it implements bus messages (e.g., \busref{GET_DEVICES}, \busref{PING}),
    those MUST follow the formats in
    \ref{sec:Virtio Transport Options / Virtio Over Messages / Bus Messages}.
\end{itemize}

\paragraph{Driver Implementation}
A \emph{driver} is compliant if:
\begin{itemize}
  \item It correctly sends and interprets all required transport messages
    (\msgref{GET_DEVICE_INFO}, \msgref{SET_DRIVER_FEATURES}, \msgref{SET_CONFIG}, etc.).
  \item It respects the bus \textbf{transport revision}  and \textbf{maximum
    message size} limits for each bus instance.
  \item It properly handles device resets, ensuring that any
    subsequent re-initialization follows
    \ref{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization}.
\end{itemize}

\paragraph{Device Implementation}
A \emph{device} is compliant if:
\begin{itemize}
  \item It supports the core transport messages and enforces the
    \emph{Configuration Generation Count}.
  \item It implements feature negotiation correctly
  \item It respects \msgref{SET_DEVICE_STATUS} changes, resetting or shutting
    down if the status is cleared.
\end{itemize}

\subsubsection{Conformance Statements}
\label{sec:Virtio Transport Options / Virtio Over Messages / Compliance / Conformance}

An implementation MUST meet all "MUST" requirements stated in:
\begin{itemize}
  \item \ref{sec:Virtio Transport Options / Virtio Over Messages / Basic Concepts} (Basic Concepts)
  \item \ref{sec:Virtio Transport Options / Virtio Over Messages / Bus Operation} (Bus Operation)
  \item \ref{sec:Virtio Transport Options / Virtio Over Messages / Device Initialization} (Device Initialization)
  \item \ref{sec:Virtio Transport Options / Virtio Over Messages / Device Operation} (Device Operation)
  \item This \ref{sec:Virtio Transport Options / Virtio Over Messages / Compliance} (Compliance) section
\end{itemize}
to claim compliance with the virtio-msg specification.

Implementations that do not follow these mandatory rules MUST NOT declare
themselves conformant. Features or messages labeled as "optional" (MAY)
do not invalidate compliance if omitted, provided all required behaviors are
still correctly implemented.
